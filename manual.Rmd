---
title: "manual"
author: "Yujie Wu"
date: '2022-03-30'
output:
  html_document: default
  pdf_document: default
---

## Manual

This file contains detailed procedure for reproducing the results presented in the paper `A Pairwise Imputation Strategy for Retaining Predictive Features When Combining Multiple Datasets'.

### Reproducing the simulation results in Section 3.1.1 when all covariates are predictive of the outcome

The generate_simple() function is used to generate data following Equation (1) of the main paper. The parameters numx controls the number of X's that are common to all studies; numxs controls the number of $X*$'s that may be missing systematically across studies; XY controls the magnitude of the coefficients corresponding to X's, and XSY controls the magnitude of the coefficients corresponding to $X^\ast$'s. 

The multiple_simple() function first performs the Omitting, pairwise linear/polynomial imputation and merged linear/polynomial imputation methods to impute the missing covariates in the training sets, and then run the LASSO regression on the merged imputed training sets to make predictions on the testing set. The paramter sim.iter controls the number of iteration to be performed, and non.miss.num controls the number of $X_3,\ldots,X_5,X_1^\ast,\ldots,X_5^\ast$'s in each training set.

The wilcox.simple() function takes the output from multiple_simple() and performs the pairwise Wilcoxon rank sum test of the prediction RMSE between different imputation methods. The parameter miss.no specifies the number of missing genes in each training set, where miss.no = (numx+numxs-2)-non.miss.num. In the plot, a red line indicates that the p-value from the paired Wilcoxon test is less than 0.01; a green line indicates that the p-value is greater than 0.01 but less than 0.05; and a blue line indicates that the p-value is greater than 0.05; and the method to which the arrow is pointing has a significantly smaller median RMSE. The number above each method presents the proportion of times each method has the smallest prediction RMSE in the validation set across the overall simulation replicates.

```{r echo=FALSE, message=FALSE}
library(MASS)
library(glmnet)
library(ggplot2)
library(dplyr)
library(mice)
generate_simple <- function(numx, numxs, XY, XSY){
  #### param@numx:        Number of X's that are common to all studies;
  #### param@numxs:       Number of X*'s that may be missing ;
  #### param@XY:          The cofficients of X's. Choices include: Low - 0.5; Medium - 1; High - 2;
  #### param@XSY:         The cofficients of X*'s. Choices include: Low - 0.5; Medium - 1; High - 2;
  if ( XY =="Low" && XSY == "Low"){
    beta <- matrix( c( rep(0.5, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Low" && XSY == "Medium"){
    beta <- matrix( c( rep(0.5, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Low" && XSY == "High"){
    beta <- matrix( c( rep(0.5, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "Low"){
    beta <- matrix( c( rep(1, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "Medium"){
    beta <- matrix( c( rep(1, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "High"){
    beta <- matrix( c( rep(1, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "Low"){
    beta <- matrix( c( rep(2, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "Medium"){
    beta <- matrix( c( rep(2, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "High"){
    beta <- matrix( c( rep(2, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  
  #### Specify the mean and covariance matrix of X
  mu <- rep(.1, (numx + numxs)) 
  sigma <- matrix(0.5, nrow =  (numx + numxs), 
                  ncol = (numx + numxs) )
  sigma <- sigma + diag(0.5, (numx + numxs)) 
  XX.star <- mvrnorm(500, mu, sigma)
  
  epsilon <- rnorm(500,0,.1) #generate noise
  
  Y <- XX.star %*% beta + epsilon #generate  return(list(X = X, Xstar = Xstar, Y = Y, XX.star = XX.star))
  df <- cbind(XX.star,Y)
  colnames(df) <- c(paste0("X", 1:numx),paste0("Xstar",1:numxs),"Y")
  return(df)
}

multiple_simple <- function(numx, numxs, XY, XSY, 
                     non.miss.num, sim.iter){
  MSE <- matrix(NA, nrow=sim.iter, ncol=5)
  colnames(MSE) <- c("Omit", "PL", "PP", "ML", "MP")
  num.impu.merge <- c()
  num.impu.pair  <- c()
  for(sim in 1:sim.iter){
    set.seed(sim)
    data <- generate_simple(numx= numx, numxs= numxs, XY=XY, XSY=XSY)
    
    index.full <- 1:500
    index1 <- sample(index.full, 100)
    index2 <- sample(index.full[-index1], 100)
    index3 <- sample(index.full[-c(index1, index2)], 100)
    index4 <- sample(index.full[-c(index1, index2, index3)], 100)
    index5 <- sample(index.full[-c(index1, index2, index3, index4)], 100)
    
    T1  <- data[index1,]
    T2  <- data[index2,]
    T3  <- data[index3,]
    T4  <- data[index4,]
    T5  <- data[index5,] ### T5 as validation set
    
    T1.true <- T1[,c(1:2, sample( 3:(numx + numxs),non.miss.num), ncol(T1))]
    T2.true <- T2[,c(1:2, sample( 3:(numx + numxs),non.miss.num), ncol(T2))]
    T3.true <- T3[,c(1:2, sample( 3:(numx + numxs),non.miss.num), ncol(T3))]
    T4.true <- T4[,c(1:2, sample( 3:(numx + numxs),non.miss.num), ncol(T4))]
    
    name1.T <- colnames(T1.true)[-ncol(T1.true)]
    name2.T <- colnames(T2.true)[-ncol(T2.true)]
    name3.T <- colnames(T3.true)[-ncol(T3.true)]
    name4.T <- colnames(T4.true)[-ncol(T4.true)]

    Name    <- matrix( nrow=4, ncol  = length(name1.T),
                       c(name1.T, name2.T, name3.T, name4.T), byrow=TRUE)

    V   <- T5

    inter2 <- intersect(name1.T, name2.T)
    inter3 <- intersect(inter2, name3.T)
    inter4 <- intersect(inter3, name4.T)
    num.impu.merge <- append(num.impu.merge, length(inter4))
    
    inter4.y <- c(inter4, "Y")
    
    T.omit <- rbind(T1[,inter4.y], T2[,inter4.y],
                    T3[,inter4.y], T4[,inter4.y])
    #### Omitting
    X.train     <- as.matrix(T.omit[, inter4])
    Y.train     <- as.matrix(T.omit[, "Y"])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.omit    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.omit   <- predict(fit.omit, as.matrix(V[,inter4]))
    MSE[sim,1]  <- mean((pred.omit -  V[,ncol(V)])^2)

    
    #### Linear knowledge transfer
    T1.impute   <- c()
    T2.impute   <- c()
    T3.impute   <- c()
    T4.impute   <- c()
    
    index.full  <- matrix(nrow = 4, ncol = 100,
                          c(index1, index2, index3, index4),
                          byrow = TRUE)
    name.full   <- Name
    combinations <- combn(4, 2)
    for(j in 1:ncol(combinations)){
      index.data1 <- index.full[combinations[,j][1],]
      index.data2 <- index.full[combinations[,j][2],]
      name1       <- name.full[combinations[,j][1],]
      name2       <- name.full[combinations[,j][2],]
      
      T.first     <- data[index.data1,][,name1]
      T.sec       <- data[index.data2,][,name2]
      names.inter <- intersect(name1, name2)
      num.impu.pair <- append(num.impu.pair, length(names.inter))
      
      name.first  <- name1[!(name1 %in% names.inter)]
      index       <- which(name1 %in% name.first)
      if(length(index) > 0){
        T.sec.impu  <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.sec.impu) <- name.first
        for(i in (1:length(index))){
          index.1         <- index[i]
          
          X.train         <- (T.first[, names.inter])
          Y.train         <- (T.first[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.impu        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          T.sec.impu[,i]  <- predict(fit.impu, T.sec[, names.inter])
        }
        if(combinations[,j][2]==1){
          T1.impute   <- cbind(T1.impute, T.sec.impu)
        }
        if(combinations[,j][2]==2){
          T2.impute   <- cbind(T2.impute, T.sec.impu)
        }
        if(combinations[,j][2]==3){
          T3.impute   <- cbind(T3.impute, T.sec.impu)
        }
        if(combinations[,j][2]==4){
          T4.impute   <- cbind(T4.impute, T.sec.impu)
        }
      } 
      
      name.sec    <- name2[!(name2 %in% names.inter)]
      index       <- which(name2 %in% name.sec)
      if(length(index) > 0){
        T.first.impu      <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.first.impu) <- name.sec
        for(i in 1:length(index)){
          index.1         <- index[i]
          X.train         <- (T.sec[, names.inter])
          Y.train         <- (T.sec[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.impu        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          T.first.impu[,i]  <- predict(fit.impu, T.first[, names.inter])
        }
        if(combinations[,j][1]==1){
          T1.impute   <- cbind(T1.impute, T.first.impu)
        }
        if(combinations[,j][1]==2){
          T2.impute   <- cbind(T2.impute, T.first.impu)
        }
        if(combinations[,j][1]==3){
          T3.impute   <- cbind(T3.impute, T.first.impu)
        }
        if(combinations[,j][1]==4){
          T4.impute   <- cbind(T4.impute, T.first.impu)
        }
      }
    }
    
    name.star <- paste0("Xstar",1:numxs)
    name.nostar <- paste0("X",3:numx)
    
    name1.impute <- colnames(T1.impute)
    name2.impute <- colnames(T2.impute)
    name3.impute <- colnames(T3.impute)
    name4.impute <- colnames(T4.impute)
    
    T1.impute2 <- c()
    T2.impute2 <- c()
    T3.impute2 <- c()
    T4.impute2 <- c()
    
    ### If a single gene is imputed multiple times,
    ###   we take the average.
    
    for(name in name.star){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
    
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    for(name in name.nostar){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    T1.true2 <- cbind(T1.true, T1.impute2)
    T2.true2 <- cbind(T2.true, T2.impute2)
    T3.true2 <- cbind(T3.true, T3.impute2)
    T4.true2 <- cbind(T4.true, T4.impute2)
    
    T1.true3 <- T1.true2[,sort(colnames(T1.true2))]
    T2.true3 <- T2.true2[,sort(colnames(T2.true2))]
    T3.true3 <- T3.true2[,sort(colnames(T3.true2))]
    T4.true3 <- T4.true2[,sort(colnames(T4.true2))]
    
    
    #### Final predicting model
    df.imput <- rbind(T1.true3, T2.true3, T3.true3, T4.true3)
    variables <- colnames(df.imput)[-length(colnames(df.imput))]
    
    X.train     <- as.matrix(df.imput[,variables])
    Y.train     <- as.matrix(df.imput[,length(colnames(df.imput))])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.impu    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.impu   <- predict(fit.impu, as.matrix(V[,variables]))
    MSE[sim,2]  <- mean((pred.impu -  V[,ncol(V)])^2)
    
    #### Polynomial 
    T1.impute   <- c()
    T2.impute   <- c()
    T3.impute   <- c()
    T4.impute   <- c()
    
    combinations <- combn(4, 2)
    for(j in 1:ncol(combinations)){
      index.data1 <- index.full[combinations[,j][1],]
      index.data2 <- index.full[combinations[,j][2],]
      name1       <- name.full[combinations[,j][1],]
      name2       <- name.full[combinations[,j][2],]
      
      T.first     <- data[index.data1,][,name1]
      T.sec       <- data[index.data2,][,name2]
      names.inter <- intersect(name1, name2)
      
      name.first  <- name1[!(name1 %in% names.inter)]
      index       <- which(name1 %in% name.first)
      if(length(index) > 0){
        T.sec.impu  <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.sec.impu) <- name.first
        for(i in (1:length(index))){
          index.1         <- index[i]
          X.train         <- (cbind(T.first[, names.inter], T.first[, names.inter]^2))
          colnames(X.train) <- c(names.inter,paste0( names.inter,"sq"))
          Y.train         <- (T.first[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          X.for.pred      <- (cbind(T.sec[, names.inter], T.sec[, names.inter]^2))
          colnames(X.for.pred) <- c(names.inter,paste0( names.inter,"sq"))
          T.sec.impu[,i]  <- predict(fit.poly, X.for.pred)
        }
        if(combinations[,j][2]==1){
          T1.impute   <- cbind(T1.impute, T.sec.impu)
        }
        if(combinations[,j][2]==2){
          T2.impute   <- cbind(T2.impute, T.sec.impu)
        }
        if(combinations[,j][2]==3){
          T3.impute   <- cbind(T3.impute, T.sec.impu)
        }
        if(combinations[,j][2]==4){
          T4.impute   <- cbind(T4.impute, T.sec.impu)
        }
      } 
      
      name.sec    <- name2[!(name2 %in% names.inter)]
      index       <- which(name2 %in% name.sec)
      if(length(index) > 0){
        T.first.impu      <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.first.impu) <- name.sec
        for(i in 1:length(index)){
          index.1         <- index[i]
          X.train         <- (cbind(T.sec[, names.inter], T.sec[, names.inter]^2))
          colnames(X.train) <- c(names.inter,paste0( names.inter,"sq"))
          Y.train         <- (T.sec[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          X.for.pred      <- (cbind(T.first[, names.inter], T.first[, names.inter]^2))
          colnames(X.for.pred) <- c(names.inter,paste0( names.inter,"sq"))
          T.first.impu[,i]<- predict(fit.poly, X.for.pred)
        }
        if(combinations[,j][1]==1){
          T1.impute   <- cbind(T1.impute, T.first.impu)
        }
        if(combinations[,j][1]==2){
          T2.impute   <- cbind(T2.impute, T.first.impu)
        }
        if(combinations[,j][1]==3){
          T3.impute   <- cbind(T3.impute, T.first.impu)
        }
        if(combinations[,j][1]==4){
          T4.impute   <- cbind(T4.impute, T.first.impu)
        }
      }
    }
    
    name.star   <- paste0("Xstar", (1:numxs))
    name.nostar <- paste0("X", (3:numx))
    
    name1.impute <- colnames(T1.impute)
    name2.impute <- colnames(T2.impute)
    name3.impute <- colnames(T3.impute)
    name4.impute <- colnames(T4.impute)
    
    T1.impute2 <- c()
    T2.impute2 <- c()
    T3.impute2 <- c()
    T4.impute2 <- c()
    
    for(name in name.star){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    for(name in name.nostar){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    T1.true2 <- cbind(T1.true, T1.impute2)
    T2.true2 <- cbind(T2.true, T2.impute2)
    T3.true2 <- cbind(T3.true, T3.impute2)
    T4.true2 <- cbind(T4.true, T4.impute2)
    
    T1.true3 <- T1.true2[,sort(colnames(T1.true2))]
    T2.true3 <- T2.true2[,sort(colnames(T2.true2))]
    T3.true3 <- T3.true2[,sort(colnames(T3.true2))]
    T4.true3 <- T4.true2[,sort(colnames(T4.true2))]
    
    #### Final predicting model
    df.poly <- rbind(T1.true3, T2.true3, T3.true3, T4.true3)
    variables <- colnames(df.poly)[-length(colnames(df.poly))]
    
    X.train     <- as.matrix(df.poly[,variables])
    Y.train     <- as.matrix(df.poly[,length(colnames(df.poly))])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.poly    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.poly   <- predict(fit.poly, V[,variables])
    MSE[sim,3]  <- mean((pred.poly -  V[,ncol(V)])^2)
    
    #### Merged imputation
    T1.true.df <- data.frame(T1.true)
    T2.true.df <- data.frame(T2.true)
    T3.true.df <- data.frame(T3.true)
    T4.true.df <- data.frame(T4.true)
    
    T1234.merge <- bind_rows(T1.true.df, T2.true.df, T3.true.df, T4.true.df)
    index.Y     <- which(colnames(T1234.merge)=="Y")
    T1234.merge <- cbind(T1234.merge[,-index.Y], T1234.merge[,index.Y])
    colnames(T1234.merge)[ncol(T1234.merge)] <- "Y"
    index.imput <- 1: (ncol(T1234.merge)-1)
    T1234.merge.linear <- T1234.merge
    T1234.merge.poly   <- T1234.merge
    
    for(kk in index.imput){
      row.index.miss <- which(is.na(T1234.merge[,kk])==TRUE)
      if(length(row.index.miss)!=0){
        #### Linear imputation
        X.train      <- as.matrix(T1234.merge[-row.index.miss, inter4 ])
        Y.train      <- T1234.merge[-row.index.miss, kk ]
        cv_fit       <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                   lambda = 10^seq(3, -2, by = -.1), 
                                   standardize = FALSE)
        opt_lambda   <- cv_fit$lambda.min
        fit.impu     <- glmnet(X.train, Y.train, alpha = 1, 
                               lambda = opt_lambda,standardize = FALSE)
        T1234.merge.linear[row.index.miss, kk]  <- predict(fit.impu, 
                                                           as.matrix(T1234.merge[row.index.miss, inter4]))
       
        
        #### polynomial imputation
        X.train      <- cbind(as.matrix(T1234.merge[-row.index.miss, inter4 ]), 
                              as.matrix(T1234.merge[-row.index.miss, inter4 ]^2))
        colnames(X.train) <- c(inter4,paste0( inter4,"sq"))
        Y.train      <- T1234.merge[-row.index.miss, kk ]
        cv_fit       <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                  lambda = 10^seq(3, -2, by = -.1), 
                                  standardize = FALSE)
        opt_lambda   <- cv_fit$lambda.min
        fit.impu     <- glmnet(X.train, Y.train, alpha = 1, 
                               lambda = opt_lambda,standardize = FALSE)
        X.for.pred   <- cbind(as.matrix(T1234.merge[row.index.miss, inter4]), 
                               as.matrix(T1234.merge[row.index.miss, inter4]^2))
        colnames(X.for.pred) <- c(inter4,paste0( inter4,"sq"))
        T1234.merge.poly[row.index.miss, kk]  <- predict(fit.impu, 
                                                           X.for.pred)
        
      }
    }
    #### predicting on merged with linear imputation
    X.train     <- as.matrix(T1234.merge.linear[,-ncol(T1234.merge.linear)])
    Y.train     <- as.matrix(T1234.merge.linear[,ncol(T1234.merge.linear)])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.merged.linear    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.merged.linear   <- predict(fit.merged.linear, V[,colnames(X.train)])
    MSE[sim,4]  <- mean((pred.merged.linear -  V[,ncol(V)])^2)
    #### predicting on merged with polynomial imputation
    X.train     <- as.matrix(T1234.merge.poly[,-ncol(T1234.merge.poly)])
    Y.train     <- as.matrix(T1234.merge.poly[,ncol(T1234.merge.poly)])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.merged.poly    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.merged.poly  <- predict(fit.merged.poly, V[,colnames(X.train)])
    MSE[sim,5]  <- mean((pred.merged.poly -  V[,ncol(V)])^2)

    
  }
  return(list(MSE=MSE,
              num.impu.pair = num.impu.pair,
              num.impu.merge = num.impu.merge))
}

wilcox.simple <- function(MSE, miss.no){
  RMSE <- sqrt(MSE)
  method.to.compare <- colnames(RMSE)
  prop.win <- matrix(0, nrow = 1, ncol = ncol(RMSE))
  colnames(prop.win) <- method.to.compare
  prop.temp <- table(apply(RMSE,1,which.min))/nrow(RMSE)
  for(i in names(prop.temp)){
    prop.win[1,as.numeric(i)] <- prop.temp[i]
  }
  df.min <- data.frame(method = method.to.compare,
                       Proportion = round(c(prop.win), 2))
  
  
  m.RMSE <- RMSE
  median.methods   <- apply(m.RMSE, 2, median)
  m.RMSE <- m.RMSE[,names(sort(median.methods))]
  
  df.min$y <- max(median.methods)
  p.value <- c()
  compare.name <- c()
  compare.jia <- c()
  compare.yi  <- c()
  order <- c()
  for(i in 1:(ncol(RMSE)-1)){
    for(j in (i+1):ncol(RMSE)){
      p.value <- append(p.value, wilcox.test(m.RMSE[,i], m.RMSE[,j],
                                             paired = TRUE)$p.value)
      if(p.value[length(p.value)] < 0.05){
        direction <- ifelse(wilcox.test(m.RMSE[,i], m.RMSE[,j],
                                        paired = TRUE, conf.int = TRUE)$estimate>0, 1, 0)
        name.1 <- colnames(m.RMSE)[i]
        name.2 <- colnames(m.RMSE)[j]
        if(direction == 1){
          compare.jia <- append(compare.jia, name.1)
          compare.yi  <- append(compare.yi, name.2)
          order       <- append(order, 0)
        } else{
          compare.jia <- append(compare.jia, name.2)
          compare.yi  <- append(compare.yi, name.1)
          order       <- append(order, 1)
        }
        compare.name <- append(compare.name, paste0(name.1,"_vs_",name.2) )
      } else{
        name.1 <- colnames(m.RMSE)[i]
        name.2 <- colnames(m.RMSE)[j]
        compare.jia <- append(compare.jia, name.1)
        compare.yi  <- append(compare.yi, name.2)
        order       <- append(order, 0)
        compare.name <- append(compare.name, paste0(name.1,"_vs_",name.2) )
      }
    }
  }
  df.test <- data.frame(p.value = p.value,
                        comparison = compare.name,
                        compare.1 = compare.jia,
                        compare.2 = compare.yi,
                        order = order)
  df.pp <- data.frame(x = factor(colnames(m.RMSE),
                                 levels = colnames(m.RMSE)),
                      y = sort(median.methods))
  df.test$p.value.ind <- ifelse(df.test$p.value<0.01, "very_sig",
                                ifelse(df.test$p.value>0.05, "insig_dif", "moderate_sig"))
  df.test$y1 <- median.methods[compare.jia]
  df.test$y2 <- median.methods[compare.yi]
  
  p <- ggplot(df.pp, aes(x=x, y=y))+
    geom_point()
  
  can.color <- c("#F8766D", "#7CAE00","#00BFC4")
  curvature <- c(0.5, 0.5, -0.5)
  names(can.color) <- c("very_sig", "moderate_sig", "insig_dif")
  names(curvature) <- c("very_sig", "moderate_sig", "insig_dif")
  for(i in 1:nrow(df.test)){
    for(sig.level in c("very_sig", "moderate_sig", "insig_dif")){
      if(df.test[i,]$p.value.ind==sig.level){
        if(sig.level != "insig_dif"){
          if(df.test[i,]$order==1){
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = -curvature[sig.level], arrow = arrow(length = unit(0.15, "cm"),
                                                             type = "closed"), show.legend = TRUE)
          } else{
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = curvature[sig.level], arrow = arrow(length = unit(0.15, "cm"),
                                                            type = "closed"), show.legend = TRUE)
          }
        } else{
          p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
          ), col = can.color[sig.level],  data = df.test[i,], 
          curvature = curvature[sig.level], show.legend = TRUE)
        }
      }
    }
  }
  
  p <- p + ylim(min(median.methods)-1.5, max(median.methods)+0.8)+
    theme_bw()+
    ylab("Median RRMSE")+
    theme(axis.title.x=element_blank(),
          legend.position = "none")+
    ggtitle(paste0("# Missing variables: ", miss.no))+
    geom_text(aes(x = method, y = y+0.6, label = Proportion),
              size = 3.5, data = df.min)
  return(p)
}

```


```{r cache=TRUE}
MSE1 <-  multiple_simple(numx=5, numxs=5, XY="Medium", XSY="Medium",
                  non.miss.num=7, sim.iter = 30)
print(wilcox.simple(MSE1$MSE, 1))
```

### Reproducing the simulation results in Section 3.1.1 when there exist noise

The function signal_data() is used to generate $X$ and $X^\ast$'s that are predictive of the outcome as the function generate_simple(). noise_data() generates the covariates that are irrelevant to the outcome and independent of the signals, where the parameter number controls the number of irrelevant genes in each study.

The multiple_sparse() function first performs the Omitting, pairwise linear/polynomial imputation and merged linear/polynomial imputation methods to impute the missing covariates in the training sets, and then run the LASSO regression on the merged imputed training sets to make predictions on the testing set. The paramter sim.iter controls the number of iteration to be performed, xxs.non.miss.num controls the number of $X_3,\ldots,X_5,X_1^\ast,\ldots,X_5^\ast$'s in each training set, and noise.non.miss.num controls the number of noises in each training set.

The wilcox.sparse() function takes the output from multiple_sparse() and performs the pairwise Wilcoxon rank sum test of the prediction RMSE between different imputation methods. The parameter miss.x specifies the number of missing predictive genes (including $X$ and $X^\ast$) in each training set, where miss.x = (numx+numxs-2)-xxs.non.miss.num. Moreover, miss.n specifies the number of missing irrelevant genes in each training set, where miss.n = number - noise.non.miss.num.

In the plot, a red line indicates that the p-value from the paired Wilcoxon test is less than 0.01; a green line indicates that the p-value is greater than 0.01 but less than 0.05; and a blue line indicates that the p-value is greater than 0.05; and the method to which the arrow is pointing has a significantly smaller median RMSE. The number above each method presents the proportion of times each method has the smallest prediction RMSE in the validation set across the overall simulation replicates.

```{r echo=FALSE}
signal_data <- function(numx, numxs, XY, XSY){
  if ( XY =="Low" && XSY == "Low"){
    beta <- matrix( c( rep(0.5, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Low" && XSY == "Medium"){
    beta <- matrix( c( rep(0.5, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Low" && XSY == "High"){
    beta <- matrix( c( rep(0.5, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "Low"){
    beta <- matrix( c( rep(1, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "Medium"){
    beta <- matrix( c( rep(1, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "High"){
    beta <- matrix( c( rep(1, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "Low"){
    beta <- matrix( c( rep(2, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "Medium"){
    beta <- matrix( c( rep(2, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "High"){
    beta <- matrix( c( rep(2, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  mu <- rep(.1, (numx + numxs)) 
  sigma <- matrix(0.5, nrow =  (numx + numxs), 
                  ncol = (numx + numxs) )
  sigma <- sigma + diag(0.5, (numx + numxs)) 
  XX.star <- mvrnorm(500, mu, sigma)
  
  epsilon <- rnorm(500,0,.1) #generate noise
  
  Y <- XX.star %*% beta + epsilon #generate  return(list(X = X, Xstar = Xstar, Y = Y, XX.star = XX.star))
  df <- cbind(XX.star,Y)
  colnames(df) <- c(paste0("X", 1:numx),paste0("Xstar",1:numxs),"Y")
  return(df)
}

noise_data <- function(number){

  mu    <- rep(.1, number) 
  sigma <- matrix(0.2, ncol = number, nrow = number)
  sigma <- sigma + diag(0.8, number)
  
  noise <- mvrnorm(500, mu, sigma)
  
  return(data.frame(noise = noise))
}

multiple_sparse <- function(numx, numxs, numnoise, XY, XSY,
                     xxs.non.miss.num, noise.non.miss.num, sim.iter){
  MSE <- matrix(NA, nrow=sim.iter, ncol=5)
  colnames(MSE) <- c("Omit", "PL", "PP", "ML", "MP")
  num.impu.merge <- c()
  num.impu.pair  <- c()
  for(sim in 1:sim.iter){
    set.seed(sim)
    signal   <- signal_data(numx = numx, numxs = numxs, XY = XY, XSY = XSY)
    noise    <- noise_data(number = numnoise)
    data     <- as.matrix(cbind(noise, signal))
    
    index.full <- 1:500
    index1 <- sample(index.full, 100)
    index2 <- sample(index.full[-index1], 100)
    index3 <- sample(index.full[-c(index1, index2)], 100)
    index4 <- sample(index.full[-c(index1, index2, index3)], 100)
    index5 <- sample(index.full[-c(index1, index2, index3, index4)], 100)
    
    T1  <- as.matrix(data[index1,])
    T2  <- as.matrix(data[index2,])
    T3  <- as.matrix(data[index3,])
    T4  <- as.matrix(data[index4,])
    T5  <- as.matrix(data[index5,]) ### T5 as validation set
    
    T1.available <- c( (numnoise+1):(numnoise+2), 
                       sample( (numnoise+3):(numnoise+numx+numxs), xxs.non.miss.num), 
                       sample( c(1:numnoise), noise.non.miss.num) )
    T1.name      <- colnames(T1)[T1.available]
    T1.true      <- T1[, c(T1.available,ncol(T1))]
    colnames(T1.true)[ncol(T1.true)] <- "Y"
    
    T2.available <- c( (numnoise+1):(numnoise+2), 
                       sample( (numnoise+3):(numnoise+numx+numxs), xxs.non.miss.num), 
                       sample( c(1:numnoise), noise.non.miss.num) )
    T2.name      <- colnames(T2)[T2.available]
    T2.true      <- T2[, c(T2.available,ncol(T2))]
    colnames(T2.true)[ncol(T2.true)] <- "Y"
    
    T3.available <- c( (numnoise+1):(numnoise+2), 
                       sample( (numnoise+3):(numnoise+numx+numxs), xxs.non.miss.num), 
                       sample( c(1:numnoise), noise.non.miss.num) )
    T3.name      <- colnames(T3)[T3.available]
    T3.true      <- T3[, c(T3.available,ncol(T3))]
    colnames(T3.true)[ncol(T3.true)] <- "Y"
    
    T4.available <- c( (numnoise+1):(numnoise+2), 
                       sample( (numnoise+3):(numnoise+numx+numxs), xxs.non.miss.num), 
                       sample( c(1:numnoise), noise.non.miss.num) )
    T4.name      <- colnames(T4)[T4.available]
    T4.true      <- T4[, c(T4.available,ncol(T4))]
    colnames(T4.true)[ncol(T4.true)] <- "Y"
    
    name1.T <- T1.name
    name2.T <- T2.name
    name3.T <- T3.name
    name4.T <- T4.name
    
    Name    <- matrix( nrow=4, ncol  = length(name1.T),
                       c(name1.T, name2.T, name3.T, name4.T), byrow=TRUE)
    
    V   <- T5
    
    inter2 <- intersect(name1.T, name2.T)
    inter3 <- intersect(inter2, name3.T)
    inter4 <- intersect(inter3, name4.T)
    num.impu.merge <- append(num.impu.merge, length(inter4))
    
    inter4.y <- c(inter4, "Y")
    
    T.omit <- rbind(T1[,inter4.y], T2[,inter4.y],
                    T3[,inter4.y], T4[,inter4.y])
    #### Omitting
    X.train     <- as.matrix(T.omit[, inter4])
    Y.train     <- as.matrix(T.omit[, "Y"])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.omit    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.omit   <- predict(fit.omit, as.matrix(V[,inter4]))
    MSE[sim,1]  <- mean((pred.omit -  V[,"Y"])^2)
    
    #### Imputation
    T1.impute   <- c()
    T2.impute   <- c()
    T3.impute   <- c()
    T4.impute   <- c()
    
    index.full  <- matrix(nrow = 4, ncol = 100,
                          c(index1, index2, index3, index4),
                          byrow = TRUE)
    name.full   <- Name
    combinations <- combn(4, 2)
    for(j in 1:ncol(combinations)){
      index.data1 <- index.full[combinations[,j][1],]
      index.data2 <- index.full[combinations[,j][2],]
      name1       <- name.full[combinations[,j][1],]
      name2       <- name.full[combinations[,j][2],]
      
      T.first     <- data[index.data1,][,name1]
      T.sec       <- data[index.data2,][,name2]
      names.inter <- intersect(name1, name2)
      num.impu.pair <- append(num.impu.pair, length(names.inter))
      
      name.first  <- name1[!(name1 %in% names.inter)]
      index       <- which(name1 %in% name.first)
      if(length(index) > 0){
        T.sec.impu  <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.sec.impu) <- name.first
        for(i in (1:length(index))){
          index.1         <- index[i]
          
          X.train         <- (T.first[, names.inter])
          Y.train         <- (T.first[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.impu        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          T.sec.impu[,i]  <- predict(fit.impu, T.sec[, names.inter])
        }
        if(combinations[,j][2]==1){
          T1.impute   <- cbind(T1.impute, T.sec.impu)
        }
        if(combinations[,j][2]==2){
          T2.impute   <- cbind(T2.impute, T.sec.impu)
        }
        if(combinations[,j][2]==3){
          T3.impute   <- cbind(T3.impute, T.sec.impu)
        }
        if(combinations[,j][2]==4){
          T4.impute   <- cbind(T4.impute, T.sec.impu)
        }
      } 
      
      name.sec    <- name2[!(name2 %in% names.inter)]
      index       <- which(name2 %in% name.sec)
      if(length(index) > 0){
        T.first.impu      <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.first.impu) <- name.sec
        for(i in 1:length(index)){
          index.1         <- index[i]
          X.train         <- (T.sec[, names.inter])
          Y.train         <- (T.sec[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.impu        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          T.first.impu[,i]  <- predict(fit.impu, T.first[, names.inter])
        }
        if(combinations[,j][1]==1){
          T1.impute   <- cbind(T1.impute, T.first.impu)
        }
        if(combinations[,j][1]==2){
          T2.impute   <- cbind(T2.impute, T.first.impu)
        }
        if(combinations[,j][1]==3){
          T3.impute   <- cbind(T3.impute, T.first.impu)
        }
        if(combinations[,j][1]==4){
          T4.impute   <- cbind(T4.impute, T.first.impu)
        }
      }
    }
    
    name.star  <- paste0("Xstar",1:numxs)
    name.x     <- paste0("X", 1:numx)
    name.noise <- paste0("noise.", 1:numnoise)
    
    name1.impute <- colnames(T1.impute)
    name2.impute <- colnames(T2.impute)
    name3.impute <- colnames(T3.impute)
    name4.impute <- colnames(T4.impute)
    
    T1.impute2 <- c()
    T2.impute2 <- c()
    T3.impute2 <- c()
    T4.impute2 <- c()
    
    for(name in name.star){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    for(name in name.x){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    for(name in name.noise){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    
    T1.true2 <- cbind(T1.true, T1.impute2)
    T2.true2 <- cbind(T2.true, T2.impute2)
    T3.true2 <- cbind(T3.true, T3.impute2)
    T4.true2 <- cbind(T4.true, T4.impute2)
    
    T1.true3 <- T1.true2[,sort(colnames(T1.true2))]
    T2.true3 <- T2.true2[,sort(colnames(T2.true2))]
    T3.true3 <- T3.true2[,sort(colnames(T3.true2))]
    T4.true3 <- T4.true2[,sort(colnames(T4.true2))]
    
    
    #### Imputation
    df.imput <- rbind(T1.true3, T2.true3, T3.true3, T4.true3)
    variables <- colnames(df.imput)[-length(colnames(df.imput))]
    
    X.train     <- as.matrix(df.imput[,variables])
    Y.train     <- as.matrix(df.imput[,length(colnames(df.imput))])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.impu    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.impu   <- predict(fit.impu, as.matrix(V[,variables]))
    MSE[sim,2]  <- mean((pred.impu -  V[,"Y"])^2)
    
    #### Polynomial KT
    T1.impute   <- c()
    T2.impute   <- c()
    T3.impute   <- c()
    T4.impute   <- c()
    
    combinations <- combn(4, 2)
    for(j in 1:ncol(combinations)){
      index.data1 <- index.full[combinations[,j][1],]
      index.data2 <- index.full[combinations[,j][2],]
      name1       <- name.full[combinations[,j][1],]
      name2       <- name.full[combinations[,j][2],]
      
      T.first     <- data[index.data1,][,name1]
      T.sec       <- data[index.data2,][,name2]
      names.inter <- intersect(name1, name2)
      
      name.first  <- name1[!(name1 %in% names.inter)]
      index       <- which(name1 %in% name.first)
      if(length(index) > 0){
        T.sec.impu  <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.sec.impu) <- name.first
        for(i in (1:length(index))){
          index.1         <- index[i]
          X.train         <- (cbind(T.first[, names.inter], T.first[, names.inter]^2))
          colnames(X.train) <- c(names.inter,paste0( names.inter,"sq"))
          Y.train         <- (T.first[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          X.for.pred      <- (cbind(T.sec[, names.inter], T.sec[, names.inter]^2))
          colnames(X.for.pred) <- c(names.inter,paste0( names.inter,"sq"))
          T.sec.impu[,i]  <- predict(fit.poly, X.for.pred)
        }
        if(combinations[,j][2]==1){
          T1.impute   <- cbind(T1.impute, T.sec.impu)
        }
        if(combinations[,j][2]==2){
          T2.impute   <- cbind(T2.impute, T.sec.impu)
        }
        if(combinations[,j][2]==3){
          T3.impute   <- cbind(T3.impute, T.sec.impu)
        }
        if(combinations[,j][2]==4){
          T4.impute   <- cbind(T4.impute, T.sec.impu)
        }
      } 
      
      name.sec    <- name2[!(name2 %in% names.inter)]
      index       <- which(name2 %in% name.sec)
      if(length(index) > 0){
        T.first.impu      <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.first.impu) <- name.sec
        for(i in 1:length(index)){
          index.1         <- index[i]
          X.train         <- (cbind(T.sec[, names.inter], T.sec[, names.inter]^2))
          colnames(X.train) <- c(names.inter,paste0( names.inter,"sq"))
          Y.train         <- (T.sec[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          X.for.pred      <- (cbind(T.first[, names.inter], T.first[, names.inter]^2))
          colnames(X.for.pred) <- c(names.inter,paste0( names.inter,"sq"))
          T.first.impu[,i]<- predict(fit.poly, X.for.pred)
        }
        if(combinations[,j][1]==1){
          T1.impute   <- cbind(T1.impute, T.first.impu)
        }
        if(combinations[,j][1]==2){
          T2.impute   <- cbind(T2.impute, T.first.impu)
        }
        if(combinations[,j][1]==3){
          T3.impute   <- cbind(T3.impute, T.first.impu)
        }
        if(combinations[,j][1]==4){
          T4.impute   <- cbind(T4.impute, T.first.impu)
        }
      }
    }
    
    name.star  <- paste0("Xstar",1:numxs)
    name.x     <- paste0("X", 1:numx)
    name.noise <- paste0("noise.", 1:numnoise)
    
    name1.impute <- colnames(T1.impute)
    name2.impute <- colnames(T2.impute)
    name3.impute <- colnames(T3.impute)
    name4.impute <- colnames(T4.impute)
    
    T1.impute2 <- c()
    T2.impute2 <- c()
    T3.impute2 <- c()
    T4.impute2 <- c()
    
    for(name in name.star){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    for(name in name.x){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    for(name in name.noise){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    
    T1.true2 <- cbind(T1.true, T1.impute2)
    T2.true2 <- cbind(T2.true, T2.impute2)
    T3.true2 <- cbind(T3.true, T3.impute2)
    T4.true2 <- cbind(T4.true, T4.impute2)
    
    T1.true3 <- T1.true2[,sort(colnames(T1.true2))]
    T2.true3 <- T2.true2[,sort(colnames(T2.true2))]
    T3.true3 <- T3.true2[,sort(colnames(T3.true2))]
    T4.true3 <- T4.true2[,sort(colnames(T4.true2))]
    
    #### Polynomial KT
    df.poly <- rbind(T1.true3, T2.true3, T3.true3, T4.true3)
    variables <- colnames(df.poly)[-length(colnames(df.poly))]
    
    X.train     <- as.matrix(df.poly[,variables])
    Y.train     <- as.matrix(df.poly[,length(colnames(df.poly))])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.poly    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.poly   <- predict(fit.poly, V[,variables])
    MSE[sim,3]  <- mean((pred.poly -  V[,"Y"])^2)
    
    #### merge
    T1.true.df <- data.frame(T1.true)
    T2.true.df <- data.frame(T2.true)
    T3.true.df <- data.frame(T3.true)
    T4.true.df <- data.frame(T4.true)
    
    T1234.merge <- bind_rows(T1.true.df, T2.true.df, T3.true.df, T4.true.df)
    index.Y     <- which(colnames(T1234.merge)=="Y")
    T1234.merge <- cbind(T1234.merge[,-index.Y], T1234.merge[,index.Y])
    colnames(T1234.merge)[ncol(T1234.merge)] <- "Y"
    index.imput <-  1: (ncol(T1234.merge)-1)
    T1234.merge.linear <- T1234.merge
    T1234.merge.poly   <- T1234.merge
    
    for(kk in index.imput){
      row.index.miss <- which(is.na(T1234.merge[,kk])==TRUE)
      if(length(row.index.miss)!=0){
        #### Linear imputation
        X.train      <- as.matrix(T1234.merge[-row.index.miss, inter4 ])
        Y.train      <- T1234.merge[-row.index.miss, kk ]
        cv_fit       <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                  lambda = 10^seq(3, -2, by = -.1), 
                                  standardize = FALSE)
        opt_lambda   <- cv_fit$lambda.min
        fit.impu     <- glmnet(X.train, Y.train, alpha = 1, 
                               lambda = opt_lambda,standardize = FALSE)
        T1234.merge.linear[row.index.miss, kk]  <- predict(fit.impu, 
                                                           as.matrix(T1234.merge[row.index.miss, inter4]))
        
        
        #### polynomial imputation
        X.train      <- cbind(as.matrix(T1234.merge[-row.index.miss, inter4 ]), 
                              as.matrix(T1234.merge[-row.index.miss, inter4 ]^2))
        colnames(X.train) <- c(inter4,paste0( inter4,"sq"))
        Y.train      <- T1234.merge[-row.index.miss, kk ]
        cv_fit       <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                  lambda = 10^seq(3, -2, by = -.1), 
                                  standardize = FALSE)
        opt_lambda   <- cv_fit$lambda.min
        fit.impu     <- glmnet(X.train, Y.train, alpha = 1, 
                               lambda = opt_lambda,standardize = FALSE)
        X.for.pred   <- cbind(as.matrix(T1234.merge[row.index.miss, inter4]), 
                              as.matrix(T1234.merge[row.index.miss, inter4]^2))
        colnames(X.for.pred) <- c(inter4,paste0( inter4,"sq"))
        T1234.merge.poly[row.index.miss, kk]  <- predict(fit.impu, 
                                                         X.for.pred)
        
      }
    }
    #### predicting on merged with linear imputation
    X.train     <- as.matrix(T1234.merge.linear[,-ncol(T1234.merge.linear)])
    Y.train     <- as.matrix(T1234.merge.linear[,ncol(T1234.merge.linear)])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.merged.linear    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.merged.linear   <- predict(fit.merged.linear, V[,colnames(X.train)])
    MSE[sim,4]  <- mean((pred.merged.linear -  V[,"Y"])^2)
    #### predicting on merged with polynomial imputation
    X.train     <- as.matrix(T1234.merge.poly[,-ncol(T1234.merge.linear)])
    Y.train     <- as.matrix(T1234.merge.poly[,ncol(T1234.merge.linear)])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.merged.poly    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.merged.poly  <- predict(fit.merged.poly, V[,colnames(X.train)])
    MSE[sim,5]  <- mean((pred.merged.poly -  V[,"Y"])^2)
    
  }
  return(list(MSE=MSE,
              num.impu.pair = num.impu.pair,
              num.impu.merge = num.impu.merge))
}
wilcox.sparse <- function(MSE, miss.x, miss.n){
  RMSE <- sqrt(MSE)
  method.to.compare <- colnames(RMSE)
  prop.win <- matrix(0, nrow = 1, ncol = ncol(RMSE))
  colnames(prop.win) <- method.to.compare
  prop.temp <- table(apply(RMSE,1,which.min))/nrow(RMSE)
  for(i in names(prop.temp)){
    prop.win[1,as.numeric(i)] <- prop.temp[i]
  }
  df.min <- data.frame(method = method.to.compare,
                       Proportion = round(c(prop.win), 2))
  
  
  m.RMSE <- RMSE
  median.methods   <- apply(m.RMSE, 2, median)
  m.RMSE <- m.RMSE[,names(sort(median.methods))]
  
  df.min$y <- max(median.methods)
  p.value <- c()
  compare.name <- c()
  compare.jia <- c()
  compare.yi  <- c()
  order <- c()
  for(i in 1:(ncol(RMSE)-1)){
    for(j in (i+1):ncol(RMSE)){
      p.value <- append(p.value, wilcox.test(m.RMSE[,i], m.RMSE[,j],
                                             paired = TRUE)$p.value)
      if(p.value[length(p.value)] < 0.05){
        direction <- ifelse(wilcox.test(m.RMSE[,i], m.RMSE[,j],
                                        paired = TRUE, conf.int = TRUE)$estimate>0, 1, 0)
        name.1 <- colnames(m.RMSE)[i]
        name.2 <- colnames(m.RMSE)[j]
        if(direction == 1){
          compare.jia <- append(compare.jia, name.1)
          compare.yi  <- append(compare.yi, name.2)
          order       <- append(order, 0)
        } else{
          compare.jia <- append(compare.jia, name.2)
          compare.yi  <- append(compare.yi, name.1)
          order       <- append(order, 1)
        }
        compare.name <- append(compare.name, paste0(name.1,"_vs_",name.2) )
      } else{
        name.1 <- colnames(m.RMSE)[i]
        name.2 <- colnames(m.RMSE)[j]
        compare.jia <- append(compare.jia, name.1)
        compare.yi  <- append(compare.yi, name.2)
        order       <- append(order, 0)
        compare.name <- append(compare.name, paste0(name.1,"_vs_",name.2) )
      }
    }
  }
  df.test <- data.frame(p.value = p.value,
                        comparison = compare.name,
                        compare.1 = compare.jia,
                        compare.2 = compare.yi,
                        order = order)
  df.pp <- data.frame(x = factor(colnames(m.RMSE),
                                 levels = colnames(m.RMSE)),
                      y = sort(median.methods))
  df.test$p.value.ind <- ifelse(df.test$p.value<0.01, "very_sig",
                                ifelse(df.test$p.value>0.05, "insig_dif", "moderate_sig"))
  df.test$y1 <- median.methods[compare.jia]
  df.test$y2 <- median.methods[compare.yi]
  
  p <- ggplot(df.pp, aes(x=x, y=y))+
    geom_point()
  
  can.color <- c("#F8766D", "#7CAE00","#00BFC4")
  curvature <- c(0.5, 0.5, -0.5)
  names(can.color) <- c("very_sig", "moderate_sig", "insig_dif")
  names(curvature) <- c("very_sig", "moderate_sig", "insig_dif")
  for(i in 1:nrow(df.test)){
    for(sig.level in c("very_sig", "moderate_sig", "insig_dif")){
      if(df.test[i,]$p.value.ind==sig.level){
        if(sig.level != "insig_dif"){
          if(df.test[i,]$order==1){
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = -curvature[sig.level], arrow = arrow(length = unit(0.15, "cm"),
                                                             type = "closed"))
          } else{
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = curvature[sig.level], arrow = arrow(length = unit(0.15, "cm"),
                                                            type = "closed"))
          }
        } else{
          p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
          ), col = can.color[sig.level],  data = df.test[i,], 
          curvature = curvature[sig.level])
        }
      }
    }
  }
  
  p <- p + ylim(min(median.methods)-1.5, max(median.methods)+0.8)+
    theme_bw()+
    ylab("Median RMSE")+
    theme(axis.title.x=element_blank(),
          legend.position = "none")+
    ggtitle(paste0("# Miss re. & irre. Var.= \n", miss.x, " and ", miss.n))+
    geom_text(aes(x = method, y = y+0.6, label = Proportion),
              size = 3.5, data = df.min)
  return(p)
}

```

```{r cache=TRUE}
MSE1.noise <-  multiple_sparse(numx=5, numxs=5, numnoise = 5, XY="Medium", XSY="Medium", xxs.non.miss.num= 7, noise.non.miss.num = 4, sim.iter = 30)
print(wilcox.sparse(MSE1.noise$MSE, 1, 1))
```

## Reproducing the simulation results in Section 3.1.2 


```{r echo=FALSE, message=FALSE}
library(MASS)
library(glmnet)
library(ggplot2)
library(dplyr)
library(mice)
generate_simple <- function(numx, numxs, XY, XSY){
  #### param@numx:        Number of X's that are common to all studies;
  #### param@numxs:       Number of X*'s that may be missing ;
  #### param@XY:          The cofficients of X's. Choices include: Low - 0.5; Medium - 1; High - 2;
  #### param@XSY:         The cofficients of X*'s. Choices include: Low - 0.5; Medium - 1; High - 2;
  if ( XY =="Low" && XSY == "Low"){
    beta <- matrix( c( rep(0.5, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Low" && XSY == "Medium"){
    beta <- matrix( c( rep(0.5, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Low" && XSY == "High"){
    beta <- matrix( c( rep(0.5, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "Low"){
    beta <- matrix( c( rep(1, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "Medium"){
    beta <- matrix( c( rep(1, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="Medium" && XSY == "High"){
    beta <- matrix( c( rep(1, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "Low"){
    beta <- matrix( c( rep(2, numx), rep(0.5, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "Medium"){
    beta <- matrix( c( rep(2, numx), rep(1, numxs)), ncol = 1 ) #coefficient
  } 
  if ( XY =="High" && XSY == "High"){
    beta <- matrix( c( rep(2, numx), rep(2, numxs)), ncol = 1 ) #coefficient
  } 
  
  #### Specify the mean and covariance matrix of X
  mu <- rep(.1, (numx + numxs)) 
  sigma <- matrix(0.5, nrow =  (numx + numxs), 
                  ncol = (numx + numxs) )
  sigma <- sigma + diag(0.5, (numx + numxs)) 
  XX.star <- mvrnorm(500, mu, sigma)
  
  epsilon <- rnorm(500,0,.1) #generate noise
  
  Y <- XX.star %*% beta + epsilon #generate  return(list(X = X, Xstar = Xstar, Y = Y, XX.star = XX.star))
  df <- cbind(XX.star,Y)
  colnames(df) <- c(paste0("X", 1:numx),paste0("Xstar",1:numxs),"Y")
  return(df)
}

multiple_simple <- function(numx, numxs, XY, XSY, 
                     non.miss.num, sim.iter){
  MSE <- matrix(NA, nrow=sim.iter, ncol=5)
  colnames(MSE) <- c("Omit", "PL", "PP", "ML", "MP")
  num.impu.merge <- c()
  num.impu.pair  <- c()
  for(sim in 1:sim.iter){
    set.seed(sim)
    data <- generate_simple(numx= numx, numxs= numxs, XY=XY, XSY=XSY)
    
    index.full <- 1:500
    index1 <- sample(index.full, 100)
    index2 <- sample(index.full[-index1], 100)
    index3 <- sample(index.full[-c(index1, index2)], 100)
    index4 <- sample(index.full[-c(index1, index2, index3)], 100)
    index5 <- sample(index.full[-c(index1, index2, index3, index4)], 100)
    
    T1  <- data[index1,]
    T2  <- data[index2,]
    T3  <- data[index3,]
    T4  <- data[index4,]
    T5  <- data[index5,] ### T5 as validation set
    
    T1.true <- T1[,c(1:2, sample( 3:(numx + numxs),non.miss.num), ncol(T1))]
    T2.true <- T2[,c(1:2, sample( 3:(numx + numxs),non.miss.num), ncol(T2))]
    T3.true <- T3[,c(1:2, sample( 3:(numx + numxs),non.miss.num), ncol(T3))]
    T4.true <- T4[,c(1:2, sample( 3:(numx + numxs),non.miss.num), ncol(T4))]
    
    name1.T <- colnames(T1.true)[-ncol(T1.true)]
    name2.T <- colnames(T2.true)[-ncol(T2.true)]
    name3.T <- colnames(T3.true)[-ncol(T3.true)]
    name4.T <- colnames(T4.true)[-ncol(T4.true)]

    Name    <- matrix( nrow=4, ncol  = length(name1.T),
                       c(name1.T, name2.T, name3.T, name4.T), byrow=TRUE)

    V   <- T5

    inter2 <- intersect(name1.T, name2.T)
    inter3 <- intersect(inter2, name3.T)
    inter4 <- intersect(inter3, name4.T)
    num.impu.merge <- append(num.impu.merge, length(inter4))
    
    inter4.y <- c(inter4, "Y")
    
    T.omit <- rbind(T1[,inter4.y], T2[,inter4.y],
                    T3[,inter4.y], T4[,inter4.y])
    #### Omitting
    X.train     <- as.matrix(T.omit[, inter4])
    Y.train     <- as.matrix(T.omit[, "Y"])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.omit    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.omit   <- predict(fit.omit, as.matrix(V[,inter4]))
    MSE[sim,1]  <- mean((pred.omit -  V[,ncol(V)])^2)

    
    #### Linear knowledge transfer
    T1.impute   <- c()
    T2.impute   <- c()
    T3.impute   <- c()
    T4.impute   <- c()
    
    index.full  <- matrix(nrow = 4, ncol = 100,
                          c(index1, index2, index3, index4),
                          byrow = TRUE)
    name.full   <- Name
    combinations <- combn(4, 2)
    for(j in 1:ncol(combinations)){
      index.data1 <- index.full[combinations[,j][1],]
      index.data2 <- index.full[combinations[,j][2],]
      name1       <- name.full[combinations[,j][1],]
      name2       <- name.full[combinations[,j][2],]
      
      T.first     <- data[index.data1,][,name1]
      T.sec       <- data[index.data2,][,name2]
      names.inter <- intersect(name1, name2)
      num.impu.pair <- append(num.impu.pair, length(names.inter))
      
      name.first  <- name1[!(name1 %in% names.inter)]
      index       <- which(name1 %in% name.first)
      if(length(index) > 0){
        T.sec.impu  <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.sec.impu) <- name.first
        for(i in (1:length(index))){
          index.1         <- index[i]
          
          X.train         <- (T.first[, names.inter])
          Y.train         <- (T.first[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.impu        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          T.sec.impu[,i]  <- predict(fit.impu, T.sec[, names.inter])
        }
        if(combinations[,j][2]==1){
          T1.impute   <- cbind(T1.impute, T.sec.impu)
        }
        if(combinations[,j][2]==2){
          T2.impute   <- cbind(T2.impute, T.sec.impu)
        }
        if(combinations[,j][2]==3){
          T3.impute   <- cbind(T3.impute, T.sec.impu)
        }
        if(combinations[,j][2]==4){
          T4.impute   <- cbind(T4.impute, T.sec.impu)
        }
      } 
      
      name.sec    <- name2[!(name2 %in% names.inter)]
      index       <- which(name2 %in% name.sec)
      if(length(index) > 0){
        T.first.impu      <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.first.impu) <- name.sec
        for(i in 1:length(index)){
          index.1         <- index[i]
          X.train         <- (T.sec[, names.inter])
          Y.train         <- (T.sec[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.impu        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          T.first.impu[,i]  <- predict(fit.impu, T.first[, names.inter])
        }
        if(combinations[,j][1]==1){
          T1.impute   <- cbind(T1.impute, T.first.impu)
        }
        if(combinations[,j][1]==2){
          T2.impute   <- cbind(T2.impute, T.first.impu)
        }
        if(combinations[,j][1]==3){
          T3.impute   <- cbind(T3.impute, T.first.impu)
        }
        if(combinations[,j][1]==4){
          T4.impute   <- cbind(T4.impute, T.first.impu)
        }
      }
    }
    
    name.star <- paste0("Xstar",1:numxs)
    name.nostar <- paste0("X",3:numx)
    
    name1.impute <- colnames(T1.impute)
    name2.impute <- colnames(T2.impute)
    name3.impute <- colnames(T3.impute)
    name4.impute <- colnames(T4.impute)
    
    T1.impute2 <- c()
    T2.impute2 <- c()
    T3.impute2 <- c()
    T4.impute2 <- c()
    
    ### If a single gene is imputed multiple times,
    ###   we take the average.
    
    for(name in name.star){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
    
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    for(name in name.nostar){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    T1.true2 <- cbind(T1.true, T1.impute2)
    T2.true2 <- cbind(T2.true, T2.impute2)
    T3.true2 <- cbind(T3.true, T3.impute2)
    T4.true2 <- cbind(T4.true, T4.impute2)
    
    T1.true3 <- T1.true2[,sort(colnames(T1.true2))]
    T2.true3 <- T2.true2[,sort(colnames(T2.true2))]
    T3.true3 <- T3.true2[,sort(colnames(T3.true2))]
    T4.true3 <- T4.true2[,sort(colnames(T4.true2))]
    
    
    #### Final predicting model
    df.imput <- rbind(T1.true3, T2.true3, T3.true3, T4.true3)
    variables <- colnames(df.imput)[-length(colnames(df.imput))]
    
    X.train     <- as.matrix(df.imput[,variables])
    Y.train     <- as.matrix(df.imput[,length(colnames(df.imput))])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.impu    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.impu   <- predict(fit.impu, as.matrix(V[,variables]))
    MSE[sim,2]  <- mean((pred.impu -  V[,ncol(V)])^2)
    
    #### Polynomial 
    T1.impute   <- c()
    T2.impute   <- c()
    T3.impute   <- c()
    T4.impute   <- c()
    
    combinations <- combn(4, 2)
    for(j in 1:ncol(combinations)){
      index.data1 <- index.full[combinations[,j][1],]
      index.data2 <- index.full[combinations[,j][2],]
      name1       <- name.full[combinations[,j][1],]
      name2       <- name.full[combinations[,j][2],]
      
      T.first     <- data[index.data1,][,name1]
      T.sec       <- data[index.data2,][,name2]
      names.inter <- intersect(name1, name2)
      
      name.first  <- name1[!(name1 %in% names.inter)]
      index       <- which(name1 %in% name.first)
      if(length(index) > 0){
        T.sec.impu  <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.sec.impu) <- name.first
        for(i in (1:length(index))){
          index.1         <- index[i]
          X.train         <- (cbind(T.first[, names.inter], T.first[, names.inter]^2))
          colnames(X.train) <- c(names.inter,paste0( names.inter,"sq"))
          Y.train         <- (T.first[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          X.for.pred      <- (cbind(T.sec[, names.inter], T.sec[, names.inter]^2))
          colnames(X.for.pred) <- c(names.inter,paste0( names.inter,"sq"))
          T.sec.impu[,i]  <- predict(fit.poly, X.for.pred)
        }
        if(combinations[,j][2]==1){
          T1.impute   <- cbind(T1.impute, T.sec.impu)
        }
        if(combinations[,j][2]==2){
          T2.impute   <- cbind(T2.impute, T.sec.impu)
        }
        if(combinations[,j][2]==3){
          T3.impute   <- cbind(T3.impute, T.sec.impu)
        }
        if(combinations[,j][2]==4){
          T4.impute   <- cbind(T4.impute, T.sec.impu)
        }
      } 
      
      name.sec    <- name2[!(name2 %in% names.inter)]
      index       <- which(name2 %in% name.sec)
      if(length(index) > 0){
        T.first.impu      <- matrix(NA, ncol=length(index), nrow=100)
        colnames(T.first.impu) <- name.sec
        for(i in 1:length(index)){
          index.1         <- index[i]
          X.train         <- (cbind(T.sec[, names.inter], T.sec[, names.inter]^2))
          colnames(X.train) <- c(names.inter,paste0( names.inter,"sq"))
          Y.train         <- (T.sec[, index.1])
          cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                       lambda = 10^seq(3, -2, by = -.1), 
                                       standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          X.for.pred      <- (cbind(T.first[, names.inter], T.first[, names.inter]^2))
          colnames(X.for.pred) <- c(names.inter,paste0( names.inter,"sq"))
          T.first.impu[,i]<- predict(fit.poly, X.for.pred)
        }
        if(combinations[,j][1]==1){
          T1.impute   <- cbind(T1.impute, T.first.impu)
        }
        if(combinations[,j][1]==2){
          T2.impute   <- cbind(T2.impute, T.first.impu)
        }
        if(combinations[,j][1]==3){
          T3.impute   <- cbind(T3.impute, T.first.impu)
        }
        if(combinations[,j][1]==4){
          T4.impute   <- cbind(T4.impute, T.first.impu)
        }
      }
    }
    
    name.star   <- paste0("Xstar", (1:numxs))
    name.nostar <- paste0("X", (3:numx))
    
    name1.impute <- colnames(T1.impute)
    name2.impute <- colnames(T2.impute)
    name3.impute <- colnames(T3.impute)
    name4.impute <- colnames(T4.impute)
    
    T1.impute2 <- c()
    T2.impute2 <- c()
    T3.impute2 <- c()
    T4.impute2 <- c()
    
    for(name in name.star){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    for(name in name.nostar){
      if(length(which(name1.impute %in% name))>1){
        temp       <- matrix(rowMeans(T1.impute[,which(name1.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2, temp)
      } else if(length(which(name1.impute %in% name))==1){
        temp       <- matrix(T1.impute[,which(name1.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T1.impute2 <- cbind(T1.impute2,temp)
      }
      
      if(length(which(name2.impute %in% name))>1){
        temp       <- matrix(rowMeans(T2.impute[,which(name2.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2, temp)
      } else if(length(which(name2.impute %in% name))==1){
        temp       <- matrix(T2.impute[,which(name2.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T2.impute2 <- cbind(T2.impute2,temp)
      }
      
      if(length(which(name3.impute %in% name))>1){
        temp       <- matrix(rowMeans(T3.impute[,which(name3.impute %in% name)]),ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2, temp)
      } else if(length(which(name3.impute %in% name))==1){
        temp       <- matrix(T3.impute[,which(name3.impute %in% name)],ncol=1)
        colnames(temp) <- name
        T3.impute2 <- cbind(T3.impute2,temp)
      }
      
      if(length(which(name4.impute %in% name))>1){
        temp       <- matrix(rowMeans(T4.impute[,which(name4.impute %in% name)]), ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2, temp)
      } else if(length(which(name4.impute %in% name))==1){
        temp       <- matrix(T4.impute[,which(name4.impute %in% name)], ncol=1)
        colnames(temp) <- name
        T4.impute2 <- cbind(T4.impute2,temp)
      }
      
    }
    
    T1.true2 <- cbind(T1.true, T1.impute2)
    T2.true2 <- cbind(T2.true, T2.impute2)
    T3.true2 <- cbind(T3.true, T3.impute2)
    T4.true2 <- cbind(T4.true, T4.impute2)
    
    T1.true3 <- T1.true2[,sort(colnames(T1.true2))]
    T2.true3 <- T2.true2[,sort(colnames(T2.true2))]
    T3.true3 <- T3.true2[,sort(colnames(T3.true2))]
    T4.true3 <- T4.true2[,sort(colnames(T4.true2))]
    
    #### Final predicting model
    df.poly <- rbind(T1.true3, T2.true3, T3.true3, T4.true3)
    variables <- colnames(df.poly)[-length(colnames(df.poly))]
    
    X.train     <- as.matrix(df.poly[,variables])
    Y.train     <- as.matrix(df.poly[,length(colnames(df.poly))])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.poly    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.poly   <- predict(fit.poly, V[,variables])
    MSE[sim,3]  <- mean((pred.poly -  V[,ncol(V)])^2)
    
    #### Merged imputation
    T1.true.df <- data.frame(T1.true)
    T2.true.df <- data.frame(T2.true)
    T3.true.df <- data.frame(T3.true)
    T4.true.df <- data.frame(T4.true)
    
    T1234.merge <- bind_rows(T1.true.df, T2.true.df, T3.true.df, T4.true.df)
    index.Y     <- which(colnames(T1234.merge)=="Y")
    T1234.merge <- cbind(T1234.merge[,-index.Y], T1234.merge[,index.Y])
    colnames(T1234.merge)[ncol(T1234.merge)] <- "Y"
    index.imput <- 1: (ncol(T1234.merge)-1)
    T1234.merge.linear <- T1234.merge
    T1234.merge.poly   <- T1234.merge
    
    for(kk in index.imput){
      row.index.miss <- which(is.na(T1234.merge[,kk])==TRUE)
      if(length(row.index.miss)!=0){
        #### Linear imputation
        X.train      <- as.matrix(T1234.merge[-row.index.miss, inter4 ])
        Y.train      <- T1234.merge[-row.index.miss, kk ]
        cv_fit       <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                   lambda = 10^seq(3, -2, by = -.1), 
                                   standardize = FALSE)
        opt_lambda   <- cv_fit$lambda.min
        fit.impu     <- glmnet(X.train, Y.train, alpha = 1, 
                               lambda = opt_lambda,standardize = FALSE)
        T1234.merge.linear[row.index.miss, kk]  <- predict(fit.impu, 
                                                           as.matrix(T1234.merge[row.index.miss, inter4]))
       
        
        #### polynomial imputation
        X.train      <- cbind(as.matrix(T1234.merge[-row.index.miss, inter4 ]), 
                              as.matrix(T1234.merge[-row.index.miss, inter4 ]^2))
        colnames(X.train) <- c(inter4,paste0( inter4,"sq"))
        Y.train      <- T1234.merge[-row.index.miss, kk ]
        cv_fit       <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                  lambda = 10^seq(3, -2, by = -.1), 
                                  standardize = FALSE)
        opt_lambda   <- cv_fit$lambda.min
        fit.impu     <- glmnet(X.train, Y.train, alpha = 1, 
                               lambda = opt_lambda,standardize = FALSE)
        X.for.pred   <- cbind(as.matrix(T1234.merge[row.index.miss, inter4]), 
                               as.matrix(T1234.merge[row.index.miss, inter4]^2))
        colnames(X.for.pred) <- c(inter4,paste0( inter4,"sq"))
        T1234.merge.poly[row.index.miss, kk]  <- predict(fit.impu, 
                                                           X.for.pred)
        
      }
    }
    #### predicting on merged with linear imputation
    X.train     <- as.matrix(T1234.merge.linear[,-ncol(T1234.merge.linear)])
    Y.train     <- as.matrix(T1234.merge.linear[,ncol(T1234.merge.linear)])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.merged.linear    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.merged.linear   <- predict(fit.merged.linear, V[,colnames(X.train)])
    MSE[sim,4]  <- mean((pred.merged.linear -  V[,ncol(V)])^2)
    #### predicting on merged with polynomial imputation
    X.train     <- as.matrix(T1234.merge.poly[,-ncol(T1234.merge.poly)])
    Y.train     <- as.matrix(T1234.merge.poly[,ncol(T1234.merge.poly)])
    cv_fit      <- cv.glmnet(X.train, Y.train, alpha = 1, 
                             lambda = 10^seq(3, -2, by = -.1), standardize = FALSE)
    opt_lambda  <- cv_fit$lambda.min
    fit.merged.poly    <- glmnet(X.train, Y.train, alpha = 1, lambda = opt_lambda,standardize = FALSE)
    pred.merged.poly  <- predict(fit.merged.poly, V[,colnames(X.train)])
    MSE[sim,5]  <- mean((pred.merged.poly -  V[,ncol(V)])^2)

    
  }
  return(list(MSE=MSE,
              num.impu.pair = num.impu.pair,
              num.impu.merge = num.impu.merge))
}

wilcox.simple <- function(MSE, miss.no){
  RMSE <- sqrt(MSE)
  method.to.compare <- colnames(RMSE)
  prop.win <- matrix(0, nrow = 1, ncol = ncol(RMSE))
  colnames(prop.win) <- method.to.compare
  prop.temp <- table(apply(RMSE,1,which.min))/nrow(RMSE)
  for(i in names(prop.temp)){
    prop.win[1,as.numeric(i)] <- prop.temp[i]
  }
  df.min <- data.frame(method = method.to.compare,
                       Proportion = round(c(prop.win), 2))
  
  
  m.RMSE <- RMSE
  median.methods   <- apply(m.RMSE, 2, median)
  m.RMSE <- m.RMSE[,names(sort(median.methods))]
  
  df.min$y <- max(median.methods)
  p.value <- c()
  compare.name <- c()
  compare.jia <- c()
  compare.yi  <- c()
  order <- c()
  for(i in 1:(ncol(RMSE)-1)){
    for(j in (i+1):ncol(RMSE)){
      p.value <- append(p.value, wilcox.test(m.RMSE[,i], m.RMSE[,j],
                                             paired = TRUE)$p.value)
      if(p.value[length(p.value)] < 0.05){
        direction <- ifelse(wilcox.test(m.RMSE[,i], m.RMSE[,j],
                                        paired = TRUE, conf.int = TRUE)$estimate>0, 1, 0)
        name.1 <- colnames(m.RMSE)[i]
        name.2 <- colnames(m.RMSE)[j]
        if(direction == 1){
          compare.jia <- append(compare.jia, name.1)
          compare.yi  <- append(compare.yi, name.2)
          order       <- append(order, 0)
        } else{
          compare.jia <- append(compare.jia, name.2)
          compare.yi  <- append(compare.yi, name.1)
          order       <- append(order, 1)
        }
        compare.name <- append(compare.name, paste0(name.1,"_vs_",name.2) )
      } else{
        name.1 <- colnames(m.RMSE)[i]
        name.2 <- colnames(m.RMSE)[j]
        compare.jia <- append(compare.jia, name.1)
        compare.yi  <- append(compare.yi, name.2)
        order       <- append(order, 0)
        compare.name <- append(compare.name, paste0(name.1,"_vs_",name.2) )
      }
    }
  }
  df.test <- data.frame(p.value = p.value,
                        comparison = compare.name,
                        compare.1 = compare.jia,
                        compare.2 = compare.yi,
                        order = order)
  df.pp <- data.frame(x = factor(colnames(m.RMSE),
                                 levels = colnames(m.RMSE)),
                      y = sort(median.methods))
  df.test$p.value.ind <- ifelse(df.test$p.value<0.01, "very_sig",
                                ifelse(df.test$p.value>0.05, "insig_dif", "moderate_sig"))
  df.test$y1 <- median.methods[compare.jia]
  df.test$y2 <- median.methods[compare.yi]
  
  p <- ggplot(df.pp, aes(x=x, y=y))+
    geom_point()
  
  can.color <- c("#F8766D", "#7CAE00","#00BFC4")
  curvature <- c(0.5, 0.5, -0.5)
  names(can.color) <- c("very_sig", "moderate_sig", "insig_dif")
  names(curvature) <- c("very_sig", "moderate_sig", "insig_dif")
  for(i in 1:nrow(df.test)){
    for(sig.level in c("very_sig", "moderate_sig", "insig_dif")){
      if(df.test[i,]$p.value.ind==sig.level){
        if(sig.level != "insig_dif"){
          if(df.test[i,]$order==1){
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = -curvature[sig.level], arrow = arrow(length = unit(0.15, "cm"),
                                                             type = "closed"), show.legend = TRUE)
          } else{
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = curvature[sig.level], arrow = arrow(length = unit(0.15, "cm"),
                                                            type = "closed"), show.legend = TRUE)
          }
        } else{
          p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
          ), col = can.color[sig.level],  data = df.test[i,], 
          curvature = curvature[sig.level], show.legend = TRUE)
        }
      }
    }
  }
  
  p <- p + ylim(min(median.methods)-1.5, max(median.methods)+0.8)+
    theme_bw()+
    ylab("Median RRMSE")+
    theme(axis.title.x=element_blank(),
          legend.position = "none")+
    ggtitle(paste0("# Missing variables: ", miss.no))+
    geom_text(aes(x = method, y = y+0.6, label = Proportion),
              size = 3.5, data = df.min)
  return(p)
}

```


```{r cache=TRUE}
MSE1 <-  multiple_simple(numx=5, numxs=5, XY="Medium", XSY="Medium",
                  non.miss.num=7, sim.iter = 30)
print(wilcox.simple(MSE1$MSE, 1))
```

### Reproducing the simulation results in Section 3.1.1 when there exist noise

The function signal_data2() is used to generate $X$ and $X^\ast$'s that are predictive of the outcome. Currently, the function can only take $\text{numx}=\text{numxs}=20$ as in the simulation setup in the paper. noise_data() generates the covariates that are irrelevant to the outcome and independent of the signals, and the function can only take $\text{number}=120$ as in the simulation setup.

The function core_vs_all() is used to compare the Core and All imputation methods described in the paper. The parameter sim.iter controls the number of iteration to be performed, and gene_num controls the number of top predictive genes in each training set to be included for the final predicting model from the preliminary screening process.

The function wilcox.realistic() takes the output from core_vs_all() and performs the pairwise Wilcoxon rank sum test of the prediction RMSE between different imputation methods. The parameter topn() reflects the number of top predictive genes in each training set that were included for the final predicting model.


```{r echo=FALSE}
signal_data2 <- function(numx, numxs, XY, XSY){
  
  if ( XY =="Low" && XSY == "High"){
    beta <- matrix( c( rep(5, numx), rep(10, numxs)), ncol = 1 ) #coefficient
  } 
  
  if ( XY =="High" && XSY == "Low"){
    beta <- matrix( c( rep(10, numx), rep(5, numxs)), ncol = 1 ) #coefficient
  } 

  mu <- rep(.1, (numx + numxs)) 
  sigma <- matrix(0.5, nrow =  (numx + numxs), 
                  ncol = (numx + numxs) )
  sigma <- sigma + diag(0.5, (numx + numxs)) 
  XX.star <- mvrnorm(300, mu, sigma)
  
  epsilon <- rnorm(300,0,.1) #generate noise
  
  Y <- XX.star %*% beta + epsilon #generate  return(list(X = X, Xstar = Xstar, Y = Y, XX.star = XX.star))
  df <- cbind(XX.star,Y)
  colnames(df) <- c(paste0("X", 1:numx),paste0("Xstar",1:numxs),"Y")
  return(df)
}


noise_data2 <- function(number){

  mu <- rep(.1, number) 
  sigma <- matrix(0.2, ncol = number, nrow = number)
  sigma <- sigma + diag(0.8, number)
  
  noise <- mvrnorm(300, mu, sigma)
  
  return(data.frame(noise = noise))
}


#######################################
core_vs_all <- function(gene_num, numx, numxs, number,
                        XY, XSY, sim.iter){
  MSE  <- list()
  core.noise.name <- list()
  all.noise.name  <- list()
  core.noise.coef <- list()
  all.noise.coef  <- list()
  
  core.genes.name <- list()
  all.genes.name  <- list()
  core.genes.coef <- list()
  all.genes.coef  <- list()
  
  T1.lasso.signal <- list()
  T2.lasso.signal <- list()
  validation.imputed <- list()
  intersect.core  <- list()
  intersect.core.signal  <- list()
  intersect.all   <- list()
  intersect.all.signal <- list()
  
  #### In core/all imputation model
  ####  the proportion of nonzero coefficients
  ####  come from signals
  core.imput.signal.prop <- list()
  all.imput.signal.prop  <- list()
  for(j in 1:sim.iter){
    set.seed(j)
    signal   <- signal_data2(numx = numx, numxs = numxs, XY = XY,
                            XSY = XSY)
    
    noise    <- noise_data2(number = number)
    
    full.data <- cbind(noise, signal)
    
    T1       <- full.data[1:100,]
    T2       <- full.data[101:200,]
    T3       <- full.data[201:300,]
    
    
    T1.available <- c(121:140, sample(141:160, 10), sample(c(1:120), 70) )
    T1.select    <- T1[, c(T1.available,161)]
    colnames(T1.select)[ncol(T1.select)] <- "ESR1"
    
    cv_fit          <- cv.glmnet(as.matrix(T1.select[,1:100]), 
                                 as.vector(T1.select[,101]), alpha = 1, 
                                 lambda = 10^seq(3, -2, by = -.1), 
                                 standardize = FALSE)
    opt_lambda      <- cv_fit$lambda.min
    fit.lasso       <- glmnet(as.matrix(T1.select[,1:100]), 
                              as.vector(T1.select[,101]), alpha = 1, 
                              lambda = opt_lambda,standardize = FALSE)
    coefficents.abs <- abs(c(as.vector(fit.lasso$beta)))
    names(coefficents.abs) <- colnames(T1.select[,-101])
    T1.name         <- names(sort(coefficents.abs, decreasing = TRUE))
    see.signal      <- substr(T1.name[1:gene_num],1,1)
    T1.lasso.signal[[j]] <- sum(see.signal=="X")
    
    T2.available <- c(121:140, sample(141:160, 10), sample(c(1:120), 70) )
    T2.select    <- T2[, c(T2.available,161)]
    colnames(T2.select)[ncol(T2.select)] <- "ESR1"
    
    cv_fit          <- cv.glmnet(as.matrix(T2.select[,1:100]), 
                                 as.vector(T2.select[,101]), alpha = 1, 
                                 lambda = 10^seq(3, -2, by = -.1), 
                                 standardize = FALSE)
    opt_lambda      <- cv_fit$lambda.min
    fit.lasso       <- glmnet(as.matrix(T2.select[,1:100]), 
                              as.vector(T2.select[,101]), alpha = 1, 
                              lambda = opt_lambda,standardize = FALSE)
    coefficents.abs <- abs(c(as.vector(fit.lasso$beta)))
    names(coefficents.abs) <- colnames(T2.select[,-101])
    T2.name         <- names(sort(coefficents.abs, decreasing = TRUE))
    see.signal2     <- substr(T2.name[1:gene_num],1,1)
    T2.lasso.signal[[j]] <- sum(see.signal2=="X")
    
    T3.available <- c(121:140, sample(141:160, 10), sample(c(1:120), 70) )
    T3.name      <- colnames(T3)[T3.available]
    T3.select    <- T3[, c(T3.available, 161)]
    colnames(T3.select)[ncol(T3.select)] <- "ESR1"
    
    
    T.name       <- cbind(T1.name, T2.name, T3.name)
    
    Study        <- cbind(rep("S1", gene_num), rep("S2", gene_num),
                          rep("S3", gene_num))
    gene.sig4 <- list()
    for(i in 1:3){
      if(i!=3){
        gene.sig4[[i]] <- cbind(T.name[,i][1:gene_num], Study[,i])
      }
      if(i==3){
        gene.sig4[[i]] <- cbind(T.name[,i], unique(Study[,i]))
      }
    }
    
    expr.sig4 <- list()
    expr.sig4[[1]] <- T1.select[,c(gene.sig4[[1]][,1], "ESR1")]
    expr.sig4[[2]] <- T2.select[,c(gene.sig4[[2]][,1], "ESR1")]
    expr.sig4[[3]] <- T3.select[,c(gene.sig4[[3]][,1], "ESR1")]
    
    gene.full <- list()
    gene.full[[1]] <- T1.select
    gene.full[[2]] <- T2.select
    gene.full[[3]] <- T3.select
    
    
    combination <- combn(3,3)
    
    
    ###############################################################################
    ###############################################################################
    ####################          Without Standardization       ###################
    ###############################################################################
    ###############################################################################
    
    
    ##############################################
    ##### Three studies no standardization   #####
    ##### Polynomial KT performed on genes   #####
    ##### outside vs inside, which one       #####
    ##############################################
    which.study <- c()
    MSE2.5.2    <- c()
    
    count <- 1
    for(comb in 1:ncol(combination))  {
      intersect1 <- intersect(gene.sig4[[combination[,comb][1]]][,1],
                              gene.sig4[[combination[,comb][2]]][,1])
      intersect2 <- intersect(intersect1,gene.sig4[[combination[,comb][3]]][,1])
      intersect.core[[j]] <- length(intersect2)
      intersect.core.signal[[j]] <- sum(substr(intersect2, 1,1) == "X")
      accuracy.temp <- rep(NA, 3)
      deviance.Train.KT.temp <- c()
      #print(intersect2)
      if(length(intersect2)>0){
        study.index <- combination[,comb]
        
        T1  <- expr.sig4[[study.index[1]]]
        T2  <- expr.sig4[[study.index[2]]]
        T3  <- expr.sig4[[study.index[3]]]
        
        intersect1 <- intersect(colnames(T1)[-ncol(T1)], colnames(T2)[-ncol(T2)])
        intersect2 <- intersect(intersect1, colnames(T3)[-ncol(T3)])
        
        #### Omitting
        if(length(intersect2)==1){
          X.omit.train <- c(T1[,intersect2], T2[, intersect2])
          Y.omit.train <- c(T1[,"ESR1"], T2[,"ESR1"])
          any.na          <- which(is.na(Y.omit.train))
          if(length(any.na)>0){
            Y.omit.train       <- Y.omit.train[-any.na]
            X.omit.train       <- X.omit.train[-any.na,]
          }
          
          X.omit.train[which(is.na(X.omit.train))] <- mean(X.omit.train,na.rm=TRUE)
          
          df.omit      <- data.frame(X=X.omit.train, Y= Y.omit.train)
          lm.omit     <- lm(Y~., df.omit)
          accuracy.temp[1] <- mean((predict(lm.omit, data.frame(X=T3[,intersect2]))-T3[,"ESR1"])^2)
          
        } else{
          X.omit.train <- as.matrix(rbind(T1[,intersect2], T2[, intersect2]))
          Y.omit.train <- as.matrix(c(T1[,"ESR1"], T2[,"ESR1"]))
          any.na          <- which(is.na(Y.omit.train))
          if(length(any.na)>0){
            Y.omit.train       <- Y.omit.train[-any.na]
            X.omit.train       <- X.omit.train[-any.na,]
          }
          for(countna in 1:ncol(X.omit.train)){
            X.omit.train[which(is.na(X.omit.train[,countna])),countna] <- mean(X.omit.train[,countna],na.rm=TRUE)
          }
          cv_fit     <- cv.glmnet(X.omit.train, Y.omit.train,  alpha = 1, 
                                  lambda = 10^seq(3, -2, by = -.1), 
                                  standardize = FALSE)
          opt_lambda      <- cv_fit$lambda.min
          glm.omit.lasso  <- glmnet(X.omit.train, Y.omit.train, alpha = 1, 
                                    lambda = opt_lambda,standardize = FALSE)
          accuracy.temp[1] <- mean((predict(glm.omit.lasso, as.matrix(T3[,intersect2]))-T3[,"ESR1"])^2,
                                   na.rm=TRUE)
          
        }
        
        #########################################
        ###### Polynomial Inside Imputation #####
        #########################################
        
        T1.name <- colnames(T1)[-ncol(T1)]
        T2.name <- colnames(T2)[-ncol(T2)]
        T3.name <- colnames(T3)[-ncol(T3)]
        
        #### impute T1 and T3
        name.2      <- T2.name[!T2.name %in% intersect2]
        index       <- which(!(T2.name %in% intersect2))
        count.in.valid <- c()
        core.imput.signal.prop.temp <- c()
        if(length(index) > 0){
          T1.imput  <- matrix(NA, ncol=length(index), nrow=nrow(T1))
          T3.imput  <- matrix(NA, ncol=length(index), nrow=nrow(T3))
          colnames(T1.imput) <- name.2
          colnames(T3.imput) <- name.2
          for(i in (1:length(index))){
            index.1         <- index[i]
            name.miss       <- T2.name[index.1]
            if( (name.miss %in% T1.name) & (name.miss %in% T3.name)){
              T1.imput[,i]  <- T1[,name.miss]
              T3.imput[,i]  <- T3[,name.miss]
            }
            if( !(name.miss %in% T1.name) & !(name.miss %in% T3.name) ){
              count.in.valid  <- append(count.in.valid, 0)
              X.train         <- as.matrix((cbind(T2[, intersect2], T2[, intersect2]^2)))
              colnames(X.train) <- c(intersect2,paste0( intersect2,"sq"))
              Y.train         <- as.matrix((T2[, index.1]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              core.imput.signal.prop.temp <- append(core.imput.signal.prop.temp,
                                                    mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred1     <- as.matrix(cbind(T1[, intersect2], T1[, intersect2]^2))
              colnames(X.for.pred1) <- c(intersect2,paste0( intersect2,"sq"))
              T1.imput[,i]  <- predict(fit.poly, X.for.pred1)
              X.for.pred3     <- as.matrix(cbind(T3[, intersect2], T3[, intersect2]^2))
              colnames(X.for.pred3) <- c(intersect2,paste0( intersect2,"sq"))
              T3.imput[,i]  <- predict(fit.poly, X.for.pred3)
            }
            if( !(name.miss %in% T1.name) & (name.miss %in% T3.name) ){
              count.in.valid  <- append(count.in.valid, 1)
              X.train         <- as.matrix((cbind(T2[, intersect2], T2[, intersect2]^2)))
              colnames(X.train) <- c(intersect2,paste0( intersect2,"sq"))
              Y.train         <- as.matrix((T2[, index.1]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              core.imput.signal.prop.temp <- append(core.imput.signal.prop.temp,
                                                    mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              X.for.pred1     <- as.matrix(cbind(T1[, intersect2], T1[, intersect2]^2))
              colnames(X.for.pred1) <- c(intersect2,paste0( intersect2,"sq"))
              T1.imput[,i]  <- predict(fit.poly, X.for.pred1)
              
              T3.imput[,i]  <- T3[,name.miss]
            }
            if( (name.miss %in% T1.name) & !(name.miss %in% T3.name) ){
              T1.imput[,i]      <- T1[,name.miss]
              count.in.valid    <- append(count.in.valid, 0)
              X.train.temp1     <- as.matrix((cbind(T2[, intersect2], T2[, intersect2]^2)))
              X.train.temp2     <- as.matrix((cbind(T1[, intersect2], T1[, intersect2]^2)))
              X.train           <- rbind(X.train.temp1, X.train.temp2) 
              
              colnames(X.train) <- c(intersect2,paste0( intersect2,"sq"))
              Y.train         <- as.matrix(c((T2[, name.miss]), T1[,name.miss]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              core.imput.signal.prop.temp <- append(core.imput.signal.prop.temp,
                                                    mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              X.for.pred3     <- as.matrix(cbind(T3[, intersect2], T3[, intersect2]^2))
              colnames(X.for.pred3) <- c(intersect2,paste0( intersect2,"sq"))
              T3.imput[,i]  <- predict(fit.poly, X.for.pred3)
            }
            
          }
        } 
        names(core.imput.signal.prop.temp) <- c(T2.name[index])
        validation.imputed[[j]]    <- c(NA, NA)
        validation.imputed[[j]][1] <- 1-mean(count.in.valid)
        
        #### impute T2 and T3
        name.1      <- T1.name[!T1.name %in% intersect2]
        index       <- which(!(T1.name %in% intersect2))
        count.in.valid2 <- c()
        core.imput.signal.prop.temp2 <- c()
        if(length(index) > 0){
          T2.imput  <- matrix(NA, ncol=length(index), nrow=nrow(T2))
          T3.imput2 <- matrix(NA, ncol=length(index), nrow=nrow(T3))
          colnames(T2.imput) <- name.1
          colnames(T3.imput2) <- name.1
          for(i in (1:length(index))){
            index.1         <- index[i]
            name.miss       <- T1.name[index.1]
            if( (name.miss %in% T2.name) & (name.miss %in% T3.name)){
              T2.imput[,i]  <- T2[,name.miss]
              T3.imput2[,i]  <- T3[,name.miss]
            }
            if( !(name.miss %in% T2.name) & !(name.miss %in% T3.name) ){
              count.in.valid2 <- append(count.in.valid2, 0)
              X.train         <- as.matrix((cbind(T1[, intersect2], T1[, intersect2]^2)))
              colnames(X.train) <- c(intersect2,paste0( intersect2,"sq"))
              Y.train         <- as.matrix((T1[, index.1]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              core.imput.signal.prop.temp2 <- append(core.imput.signal.prop.temp2,
                                                     mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred1     <- as.matrix(cbind(T2[, intersect2], T2[, intersect2]^2))
              colnames(X.for.pred1) <- c(intersect2,paste0( intersect2,"sq"))
              T2.imput[,i]  <- predict(fit.poly, X.for.pred1)
              X.for.pred3     <- as.matrix(cbind(T3[, intersect2], T3[, intersect2]^2))
              colnames(X.for.pred3) <- c(intersect2,paste0( intersect2,"sq"))
              T3.imput2[,i]  <- predict(fit.poly, X.for.pred3)
            }
            if( !(name.miss %in% T2.name) & (name.miss %in% T3.name) ){
              count.in.valid2 <- append(count.in.valid2, 1)
              X.train         <- as.matrix((cbind(T1[, intersect2], T1[, intersect2]^2)))
              colnames(X.train) <- c(intersect2,paste0( intersect2,"sq"))
              Y.train         <- as.matrix((T1[, index.1]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              core.imput.signal.prop.temp2 <- append(core.imput.signal.prop.temp2,
                                                     mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred1     <- as.matrix(cbind(T2[, intersect2], T2[, intersect2]^2))
              colnames(X.for.pred1) <- c(intersect2,paste0( intersect2,"sq"))
              T2.imput[,i]  <- predict(fit.poly, X.for.pred1)
              
              T3.imput2[,i]  <- T3[,name.miss]
            }
            if( (name.miss %in% T2.name) & !(name.miss %in% T3.name) ){
              T2.imput[,i]      <- T2[,name.miss]
              count.in.valid2 <- append(count.in.valid2, 0)
              
              X.train.temp1     <- as.matrix((cbind(T2[, intersect2], T2[, intersect2]^2)))
              X.train.temp2     <- as.matrix((cbind(T1[, intersect2], T1[, intersect2]^2)))
              X.train           <- rbind(X.train.temp1, X.train.temp2) 
              
              colnames(X.train) <- c(intersect2,paste0( intersect2,"sq"))
              Y.train         <- as.matrix(c((T1[, name.miss]), T2[,name.miss]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              core.imput.signal.prop.temp2 <- append(core.imput.signal.prop.temp2,
                                                     mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred3     <- as.matrix(cbind(T3[, intersect2], T3[, intersect2]^2))
              colnames(X.for.pred3) <- c(intersect2,paste0( intersect2,"sq"))
              T3.imput2[,i]  <- predict(fit.poly, X.for.pred3)
            }
            
          }
        } 
        names(core.imput.signal.prop.temp2) <- c(T1.name[index])
        
        validation.imputed[[j]][2] <- 1-mean(count.in.valid2)
        core.imput.signal.prop[[j]] <- c(core.imput.signal.prop.temp, 
                                         core.imput.signal.prop.temp2)
        check.T1.name <- name.1
        check.T1.imput.name <- colnames(T1.imput)
        duplicate.imput.T1.index  <- which(check.T1.imput.name %in% check.T1.name)
        lendup1 <- length(duplicate.imput.T1.index)
        
        check.T2.name <- name.2
        check.T2.imput.name <- colnames(T2.imput)
        duplicate.imput.T2.index  <- which(check.T2.imput.name %in% check.T2.name)
        lendup2 <- length(duplicate.imput.T2.index)
        
        
        check.T3.imput.name  <- colnames(T3.imput)
        check.T3.imput2.name <- colnames(T3.imput2)
        duplicate.imput.T3.index  <- which(check.T3.imput2.name %in% check.T3.imput.name)
        lendup3 <- length(duplicate.imput.T3.index)
        
        if(length(intersect2)==1){
          if(lendup1!=0){
            T1.KT   <- cbind(T1[,intersect2], T1[,name.1], T1.imput[,-duplicate.imput.T1.index])
          } else{
            T1.KT   <- cbind(T1[,intersect2], T1[,name.1], T1.imput)
          }
          if(lendup2!=0){
            T2.KT   <- cbind(T2[,intersect2], T2[,name.2], T2.imput[,-duplicate.imput.T2.index])
          } else{
            T2.KT   <- cbind(T2[,intersect2], T2[,name.2], T2.imput)
          }
          colnames(T1.KT)[1] <- intersect2 
          colnames(T2.KT)[1] <- intersect2 
          T1.KT   <- T1.KT[,sort(colnames(T1.KT))]
          T2.KT   <- T2.KT[,sort(colnames(T2.KT))]
          T1.KT   <- cbind(T1.KT, ESR1=T1[,"ESR1"])
          T2.KT   <- cbind(T2.KT, ESR1=T2[,"ESR1"])
          
          
          if(lendup3!=0){
            T3.KT   <- cbind(T3[,intersect2], T3.imput, T3.imput2[,-duplicate.imput.T3.index])
          } else{
            T3.KT   <- cbind(T3[,intersect2], T3.imput, T3.imput2)
          }          
          colnames(T3.KT)[1] <- intersect2 
          
          T3.KT   <- T3.KT[,sort(colnames(T3.KT))]
          T3.KT   <- cbind(T3.KT, ESR1=T3[,"ESR1"])
          
        } else{
          if(lendup1!=0){
            T1.KT   <- cbind(T1[,intersect2], T1[,name.1], T1.imput[,-duplicate.imput.T1.index])
          } else{
            T1.KT   <- cbind(T1[,intersect2], T1[,name.1], T1.imput)
          }
          if(lendup2!=0){
            T2.KT   <- cbind(T2[,intersect2], T2[,name.2], T2.imput[,-duplicate.imput.T2.index])
          } else{
            T2.KT   <- cbind(T2[,intersect2], T2[,name.2], T2.imput)
          }
          T1.KT   <- T1.KT[,sort(colnames(T1.KT))]
          T2.KT   <- T2.KT[,sort(colnames(T2.KT))]
          T1.KT   <- cbind(T1.KT, ESR1=T1[,"ESR1"])
          T2.KT   <- cbind(T2.KT, ESR1=T2[,"ESR1"])
          
          
          if(lendup3!=0){
            T3.KT   <- cbind(T3[,intersect2], T3.imput, T3.imput2[,-duplicate.imput.T3.index])
          } else{
            T3.KT   <- cbind(T3[,intersect2], T3.imput, T3.imput2)
          }        
          T3.KT   <- T3.KT[,sort(colnames(T3.KT))]
          T3.KT   <- cbind(T3.KT, ESR1=T3[,"ESR1"])
        }
        
        
        T12.poly <- rbind(T1.KT, T2.KT)
        
        X.poly.train <- as.matrix(T12.poly[,-ncol(T12.poly)])
        Y.poly.train <- as.matrix(T12.poly[,"ESR1"])
        for(row in 1:nrow(X.poly.train)){
          X.temp <- X.poly.train[row,]
          index.na <- which(is.na(X.temp))
          if(length(index.na)>0){
            X.poly.train[row,index.na] <- mean(X.temp, na.rm=TRUE)
          }
        }
        cv_fit     <- cv.glmnet(X.poly.train, Y.poly.train, alpha = 1, 
                                lambda = 10^seq(3, -2, by = -.1), 
                                standardize = FALSE)
        opt_lambda      <- cv_fit$lambda.min
        glm.in.lasso  <- glmnet(X.poly.train, Y.poly.train, alpha = 1, 
                                lambda = opt_lambda,standardize = FALSE)
        
        accuracy.temp[3] <- mean((predict(glm.in.lasso, as.matrix(T3.KT[,-ncol(T3.KT)]))-T3[,"ESR1"])^2,
                                 na.rm=TRUE)
        
        non.zero          <- rownames(glm.in.lasso$beta)[which(glm.in.lasso$beta!=0)]
        first.cha         <- substr(non.zero,1, 1)
        noise.nonzero     <- non.zero[which(first.cha == "n")]
        genes.nonzero     <- non.zero[which(first.cha == "X")]
        
        core.noise.name[[j]] <- noise.nonzero
        core.noise.coef[[j]] <- glm.in.lasso$beta[noise.nonzero,]
        core.genes.name[[j]] <- genes.nonzero
        core.genes.coef[[j]] <- glm.in.lasso$beta[genes.nonzero,]
        
        
        
        ##########################################
        ###### Polynomial Outside Imputation #####
        ##########################################
        T1.full <- gene.full[[study.index[1]]]
        ESR1.index1 <- which(colnames(T1.full)=="ESR1")
        if(length(ESR1.index1)>0){
          T1.full <- T1.full[,-ESR1.index1]
        }
        T1.full.gene.name <- colnames(T1.full)
        
        T2.full <- gene.full[[study.index[2]]]
        ESR1.index2 <- which(colnames(T2.full)=="ESR1")
        if(length(ESR1.index2)>0){
          T2.full <- T2.full[,-ESR1.index2]
        }
        T2.full.gene.name <- colnames(T2.full)
        
        
        T3.full <- gene.full[[study.index[3]]]
        ESR1.index3 <- which(colnames(T3.full)=="ESR1")
        if(length(ESR1.index3)>0){
          T3.full <- T3.full[,-ESR1.index3]
        }
        T3.full.gene.name <- colnames(T3.full)
        
        
        full.intersect1 <- intersect(colnames(T1.full), colnames(T2.full))
        full.intersect2 <- intersect(full.intersect1, colnames(T3.full))
        intersect.all[[j]] <- full.intersect2
        intersect.all.signal[[j]] <- sum(substr(full.intersect2, 1,1) == "X")
        
        T1.name <- colnames(T1)[-ncol(T1)]
        T2.name <- colnames(T2)[-ncol(T2)]
        T3.name <- colnames(T3)[-ncol(T3)]
        
        #### impute T1 and T3
        KT.outside.coef.intersected   <- c()
        KT.outside.coef.nointersected <- c()
        all.imput.signal.prop.temp    <- c()
        name.2      <- T2.name[!T2.name %in% intersect2]
        index       <- which(!(T2.name %in% intersect2))
        name.temp   <- c()
        if(length(index) > 0){
          T1.imput  <- matrix(NA, ncol=length(index), nrow=nrow(T1))
          T3.imput  <- matrix(NA, ncol=length(index), nrow=nrow(T3))
          colnames(T1.imput) <- name.2
          colnames(T3.imput) <- name.2
          for(i in (1:length(index))){
            index.1         <- index[i]
            name.miss       <- T2.name[index.1]
            if( (name.miss %in% T1.full.gene.name) & (name.miss %in% T3.full.gene.name)){
              T1.imput[,i]  <- T1.full[,name.miss]
              T3.imput[,i]  <- T3.full[,name.miss]
            }
            if( !(name.miss %in% T1.full.gene.name) & !(name.miss %in% T3.full.gene.name) ){
              name.temp       <- append(name.temp, name.miss)
              X.train         <- as.matrix((cbind(T2.full[, full.intersect2], T2.full[, full.intersect2]^2)))
              colnames(X.train) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              Y.train         <- as.matrix((T2[, index.1]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              all.imput.signal.prop.temp <- append(all.imput.signal.prop.temp,
                                                   mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              X.for.pred1     <- as.matrix(cbind(T1.full[, full.intersect2], T1.full[, full.intersect2]^2))
              colnames(X.for.pred1) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              T1.imput[,i]  <- predict(fit.poly, X.for.pred1)
              X.for.pred3     <- as.matrix(cbind(T3.full[, full.intersect2], T3.full[, full.intersect2]^2))
              colnames(X.for.pred3) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              T3.imput[,i]  <- predict(fit.poly, X.for.pred3)
            }
            if( !(name.miss %in% T1.full.gene.name) & (name.miss %in% T3.full.gene.name) ){
              name.temp       <- append(name.temp, name.miss)
              X.train         <- as.matrix((cbind(T2.full[, full.intersect2], T2.full[, full.intersect2]^2)))
              colnames(X.train) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              Y.train         <- as.matrix((T2[, index.1]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              all.imput.signal.prop.temp <- append(all.imput.signal.prop.temp,
                                                   mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred1     <- as.matrix(cbind(T1.full[, full.intersect2], T1.full[, full.intersect2]^2))
              colnames(X.for.pred1) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              T1.imput[,i]  <- predict(fit.poly, X.for.pred1)
              
              T3.imput[,i]  <- T3.full[,name.miss]
            }
            if( (name.miss %in% T1.full.gene.name) & !(name.miss %in% T3.full.gene.name) ){
              name.temp         <- append(name.temp, name.miss)
              T1.imput[,i]      <- T1.full[,name.miss]
              
              X.train.temp1     <- as.matrix((cbind(T2.full[, full.intersect2], T2.full[, full.intersect2]^2)))
              X.train.temp2     <- as.matrix((cbind(T1.full[, full.intersect2], T1.full[, full.intersect2]^2)))
              X.train           <- rbind(X.train.temp1, X.train.temp2) 
              
              colnames(X.train) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              Y.train         <- as.matrix(c((T2[, name.miss]), T1.full[,name.miss]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              all.imput.signal.prop.temp <- append(all.imput.signal.prop.temp,
                                                   mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred3     <- as.matrix(cbind(T3.full[, full.intersect2], T3.full[, full.intersect2]^2))
              colnames(X.for.pred3) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              T3.imput[,i]  <- predict(fit.poly, X.for.pred3)
            }
            
          }
        } 
        
        
        #### impute T2 and T3
        
        name.1      <- T1.name[!T1.name %in% intersect2]
        index       <- which(!(T1.name %in% intersect2))
        if(length(index) > 0){
          T2.imput  <- matrix(NA, ncol=length(index), nrow=nrow(T2))
          T3.imput2  <- matrix(NA, ncol=length(index), nrow=nrow(T3))
          colnames(T2.imput) <- name.1
          colnames(T3.imput2) <- name.1
          for(i in (1:length(index))){
            index.1         <- index[i]
            name.miss       <- T1.name[index.1]
            if( (name.miss %in% T2.full.gene.name) & (name.miss %in% T3.full.gene.name)){
              T2.imput[,i]  <- T2.full[,name.miss]
              T3.imput2[,i] <- T3.full[,name.miss]
            }
            if( !(name.miss %in% T2.full.gene.name) & !(name.miss %in% T3.full.gene.name) ){
              name.temp         <- append(name.temp, name.miss)
              
              X.train         <- as.matrix((cbind(T1.full[, full.intersect2], T1.full[, full.intersect2]^2)))
              colnames(X.train) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              Y.train         <- as.matrix((T1[, index.1]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              all.imput.signal.prop.temp <- append(all.imput.signal.prop.temp,
                                                   mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred2     <- as.matrix(cbind(T2.full[, full.intersect2], T2.full[, full.intersect2]^2))
              colnames(X.for.pred2) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              T2.imput[,i]    <- predict(fit.poly, X.for.pred2)
              X.for.pred3     <- as.matrix(cbind(T3.full[, full.intersect2], T3.full[, full.intersect2]^2))
              colnames(X.for.pred3) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              T3.imput2[,i]   <- predict(fit.poly, X.for.pred3)
            }
            if( !(name.miss %in% T2.full.gene.name) & (name.miss %in% T3.full.gene.name) ){
              name.temp         <- append(name.temp, name.miss)
              
              X.train         <- as.matrix((cbind(T1.full[, full.intersect2], T1.full[, full.intersect2]^2)))
              colnames(X.train) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              Y.train         <- as.matrix((T1[, index.1]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              all.imput.signal.prop.temp <- append(all.imput.signal.prop.temp,
                                                   mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred2     <- as.matrix(cbind(T2.full[, full.intersect2], T2.full[, full.intersect2]^2))
              colnames(X.for.pred2) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              T2.imput[,i]  <- predict(fit.poly, X.for.pred2)
              
              T3.imput2[,i]  <- T3.full[,name.miss]
            }
            if( (name.miss %in% T2.full.gene.name) & !(name.miss %in% T3.full.gene.name) ){
              name.temp         <- append(name.temp, name.miss)
              
              T2.imput[,i]      <- T2.full[,name.miss]
              
              X.train.temp1     <- as.matrix((cbind(T2.full[, full.intersect2], T2.full[, full.intersect2]^2)))
              X.train.temp2     <- as.matrix((cbind(T1.full[, full.intersect2], T1.full[, full.intersect2]^2)))
              X.train           <- rbind(X.train.temp1, X.train.temp2) 
              
              colnames(X.train) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              Y.train         <- as.matrix(c((T1[, name.miss]), T2.full[,name.miss]))
              any.na          <- which(is.na(Y.train))
              if(length(any.na)>0){
                Y.train       <- Y.train[-any.na]
                X.train       <- X.train[-any.na,]
              }
              for(countna in 1:ncol(X.train)){
                X.train[which(is.na(X.train[,countna])),countna] <- mean(X.train[,countna],na.rm=TRUE)
              }
              
              cv_fit          <- cv.glmnet(X.train, Y.train, alpha = 1, 
                                           lambda = 10^seq(3, -2, by = -.1), 
                                           standardize = FALSE)
              opt_lambda      <- cv_fit$lambda.min
              fit.poly        <- glmnet(X.train, Y.train, alpha = 1, 
                                        lambda = opt_lambda,standardize = FALSE)
              all.imput.signal.prop.temp <- append(all.imput.signal.prop.temp,
                                                   mean(substr(colnames(X.train)[which(fit.poly$beta!=0)],1,1)=="X"))
              
              X.for.pred3     <- as.matrix(cbind(T3.full[, full.intersect2], T3.full[, full.intersect2]^2))
              colnames(X.for.pred3) <- c(full.intersect2,paste0( full.intersect2,"sq"))
              T3.imput2[,i]  <- predict(fit.poly, X.for.pred3)
            }
          }
        } 
        names(all.imput.signal.prop.temp) <- name.temp
        
        all.imput.signal.prop[[j]] <- c(all.imput.signal.prop.temp)
        
        check.T1.name <- name.1
        check.T1.imput.name <- colnames(T1.imput)
        duplicate.imput.T1.index  <- which(check.T1.imput.name %in% check.T1.name)
        lendup1 <- length(duplicate.imput.T1.index)
        
        check.T2.name <- name.2
        check.T2.imput.name <- colnames(T2.imput)
        duplicate.imput.T2.index  <- which(check.T2.imput.name %in% check.T2.name)
        lendup2 <- length(duplicate.imput.T2.index)
        
        
        check.T3.imput.name  <- colnames(T3.imput)
        check.T3.imput2.name <- colnames(T3.imput2)
        duplicate.imput.T3.index  <- which(check.T3.imput2.name %in% check.T3.imput.name)
        lendup3 <- length(duplicate.imput.T3.index)
        
        if(length(intersect2)==1){
          if(lendup1!=0){
            T1.KT   <- cbind(T1[,intersect2], T1[,name.1], T1.imput[,-duplicate.imput.T1.index])
          } else{
            T1.KT   <- cbind(T1[,intersect2], T1[,name.1], T1.imput)
          }
          if(lendup2!=0){
            T2.KT   <- cbind(T2[,intersect2], T2[,name.2], T2.imput[,-duplicate.imput.T2.index])
          } else{
            T2.KT   <- cbind(T2[,intersect2], T2[,name.2], T2.imput)
          }
          colnames(T1.KT)[1] <- intersect2 
          colnames(T2.KT)[1] <- intersect2 
          T1.KT   <- T1.KT[,sort(colnames(T1.KT))]
          T2.KT   <- T2.KT[,sort(colnames(T2.KT))]
          T1.KT   <- cbind(T1.KT, ESR1=T1[,"ESR1"])
          T2.KT   <- cbind(T2.KT, ESR1=T2[,"ESR1"])
          
          
          if(lendup3!=0){
            T3.KT   <- cbind(T3[,intersect2], T3.imput, T3.imput2[,-duplicate.imput.T3.index])
          } else{
            T3.KT   <- cbind(T3[,intersect2], T3.imput, T3.imput2)
          }          
          colnames(T3.KT)[1] <- intersect2 
          
          T3.KT   <- T3.KT[,sort(colnames(T3.KT))]
          T3.KT   <- cbind(T3.KT, ESR1=T3[,"ESR1"])
          
        } else{
          if(lendup1!=0){
            T1.KT   <- cbind(T1[,intersect2], T1[,name.1], T1.imput[,-duplicate.imput.T1.index])
          } else{
            T1.KT   <- cbind(T1[,intersect2], T1[,name.1], T1.imput)
          }
          if(lendup2!=0){
            T2.KT   <- cbind(T2[,intersect2], T2[,name.2], T2.imput[,-duplicate.imput.T2.index])
          } else{
            T2.KT   <- cbind(T2[,intersect2], T2[,name.2], T2.imput)
          }
          T1.KT   <- T1.KT[,sort(colnames(T1.KT))]
          T2.KT   <- T2.KT[,sort(colnames(T2.KT))]
          T1.KT   <- cbind(T1.KT, ESR1=T1[,"ESR1"])
          T2.KT   <- cbind(T2.KT, ESR1=T2[,"ESR1"])
          
          
          if(lendup3!=0){
            T3.KT   <- cbind(T3[,intersect2], T3.imput, T3.imput2[,-duplicate.imput.T3.index])
          } else{
            T3.KT   <- cbind(T3[,intersect2], T3.imput, T3.imput2)
          }        
          T3.KT   <- T3.KT[,sort(colnames(T3.KT))]
          T3.KT   <- cbind(T3.KT, ESR1=T3[,"ESR1"])
        }
        
        
        T12.poly <- rbind(T1.KT, T2.KT)
        
        X.poly.train <- as.matrix(T12.poly[,-ncol(T12.poly)])
        Y.poly.train <- as.matrix(T12.poly[,"ESR1"])
        for(row in 1:nrow(X.poly.train)){
          X.temp <- X.poly.train[row,]
          index.na <- which(is.na(X.temp))
          if(length(index.na)>0){
            X.poly.train[row,index.na] <- mean(X.temp, na.rm=TRUE)
          }
        }
        cv_fit     <- cv.glmnet(X.poly.train, Y.poly.train, alpha = 1, 
                                lambda = 10^seq(3, -2, by = -.1), 
                                standardize = FALSE)
        opt_lambda      <- cv_fit$lambda.min
        glm.poly.out  <- glmnet(X.poly.train, Y.poly.train, alpha = 1, 
                                lambda = opt_lambda,standardize = FALSE)
        accuracy.temp[2] <- mean((predict(glm.poly.out, as.matrix(T3.KT[,-ncol(T3.KT)]))-T3[,"ESR1"])^2,
                                 na.rm=TRUE)
        
        non.zero          <- rownames(glm.poly.out$beta)[which(glm.poly.out$beta!=0)]
        first.cha         <- substr(non.zero,1, 1)
        noise.nonzero     <- non.zero[which(first.cha == "n")]
        genes.nonzero     <- non.zero[which(first.cha == "X")]
        
        
        all.noise.name[[j]] <- noise.nonzero
        all.noise.coef[[j]] <- glm.poly.out$beta[noise.nonzero,]
        
        all.genes.name[[j]] <- genes.nonzero
        all.genes.coef[[j]] <- glm.poly.out$beta[genes.nonzero,]
        
        MSE2.5.2   <- rbind(MSE2.5.2, accuracy.temp)
        
        count <- count +1
        
      }
    }
    MSE[[j]]  <- MSE2.5.2
  }
  return(list(MSE = MSE,
              core.noise.name = core.noise.name,
              core.noise.coef = core.noise.coef,
              all.noise.name  = all.noise.name,
              all.noise.coef  = all.noise.coef,
              core.genes.name = core.genes.name,
              core.genes.coef = core.genes.coef,
              all.genes.name  = all.genes.name,
              all.genes.coef  = all.genes.coef,
              
              T1.lasso.signal = T1.lasso.signal,
              T2.lasso.signal = T2.lasso.signal,
              validation.imputed = validation.imputed,
              intersect.core  = intersect.core,
              intersect.core.signal = intersect.core.signal,
              intersect.all   = intersect.all,
              intersect.all.signal = intersect.all.signal,
              
              core.imput.signal.prop = core.imput.signal.prop,
              all.imput.signal.prop  = all.imput.signal.prop))
}
wilcox.realistic <- function(MSE, topn){
  RMSE <- sqrt(MSE)
  method.to.compare <- colnames(RMSE)
  prop.win <- matrix(0, nrow = 1, ncol = ncol(RMSE))
  colnames(prop.win) <- method.to.compare
  prop.temp <- table(apply(RMSE,1,which.min))/nrow(RMSE)
  for(i in names(prop.temp)){
    prop.win[1,as.numeric(i)] <- prop.temp[i]
  }
  df.min <- data.frame(method = method.to.compare,
                       Proportion = round(c(prop.win), 2))
  
  
  m.RMSE <- RMSE
  median.methods   <- apply(m.RMSE, 2, median)
  m.RMSE <- m.RMSE[,names(sort(median.methods))]
  
  df.min$y <- max(median.methods)
  p.value <- c()
  compare.name <- c()
  compare.jia <- c()
  compare.yi  <- c()
  order <- c()
  for(i in 1:(ncol(RMSE)-1)){
    for(j in (i+1):ncol(RMSE)){
      p.value <- append(p.value, wilcox.test(m.RMSE[,i], m.RMSE[,j],
                                             paired = TRUE)$p.value)
      if(p.value[length(p.value)] < 0.05){
        direction <- ifelse(wilcox.test(m.RMSE[,i], m.RMSE[,j],
                                        paired = TRUE, conf.int = TRUE)$estimate>0, 1, 0)
        name.1 <- colnames(m.RMSE)[i]
        name.2 <- colnames(m.RMSE)[j]
        if(direction == 1){
          compare.jia <- append(compare.jia, name.1)
          compare.yi  <- append(compare.yi, name.2)
          order       <- append(order, 0)
        } else{
          compare.jia <- append(compare.jia, name.2)
          compare.yi  <- append(compare.yi, name.1)
          order       <- append(order, 1)
        }
        compare.name <- append(compare.name, paste0(name.1,"_vs_",name.2) )
      } else{
        name.1 <- colnames(m.RMSE)[i]
        name.2 <- colnames(m.RMSE)[j]
        compare.jia <- append(compare.jia, name.1)
        compare.yi  <- append(compare.yi, name.2)
        order       <- append(order, 0)
        compare.name <- append(compare.name, paste0(name.1,"_vs_",name.2) )
      }
    }
  }
  df.test <- data.frame(p.value = p.value,
                        comparison = compare.name,
                        compare.1 = compare.jia,
                        compare.2 = compare.yi,
                        order = order)
  df.pp <- data.frame(x = factor(colnames(m.RMSE),
                                 levels = colnames(m.RMSE)),
                      y = sort(median.methods))
  df.test$p.value.ind <- ifelse(df.test$p.value<0.01, "very_sig",
                                ifelse(df.test$p.value>0.05, "insig_dif", "moderate_sig"))
  df.test$y1 <- median.methods[compare.jia]
  df.test$y2 <- median.methods[compare.yi]
  
  p <- ggplot(df.pp, aes(x=x, y=y))+
    geom_point()
  
  can.color <- c("#F8766D", "#7CAE00","#00BFC4")
  curvature <- c(0.5, 0.5, -0.5)
  names(can.color) <- c("very_sig", "moderate_sig", "insig_dif")
  names(curvature) <- c("very_sig", "moderate_sig", "insig_dif")
  for(i in 1:nrow(df.test)){
    for(sig.level in c("very_sig", "moderate_sig", "insig_dif")){
      if(df.test[i,]$p.value.ind==sig.level){
        if(sig.level != "insig_dif"){
          if(df.test[i,]$order==1){
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = -curvature[sig.level], arrow = arrow(length = unit(0.2, "cm"),
                                                             type = "closed"))
          } else{
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = curvature[sig.level],arrow = arrow(length = unit(0.2, "cm"),
                                                           type = "closed"))
          }
        } else{
            p <- p + geom_curve(aes(x = compare.1, y = y1, xend = compare.2, yend = y2,
            ), col = can.color[sig.level],  data = df.test[i,], 
            curvature = curvature[sig.level])
        }
      }
    }
  }
  
  p <- p + ylim(min(median.methods)-1.5, max(median.methods)+3)+
    theme_bw()+
    ylab("Median RMSE")+
    theme(axis.title.x=element_blank(),
          legend.position = "none")+
    ggtitle(paste0("# Top variables: ", topn))+
    geom_text(aes(x = method, y = y+2, label = Proportion),
              size = 3.5, data = df.min)
  return(p)
}

```

```{r cache=TRUE}
top30 <- core_vs_all(30, 20, 20, 120, "High", "Low", 10)
result30 <- matrix(NA, ncol = 3, nrow = 10)
for(i in 1:10){
  result30[i,] <- top30$MSE[[i]]
}
colnames(result30) <- c("Omitting", "All", "Core")
print(wilcox.realistic(result30, 30))
```


